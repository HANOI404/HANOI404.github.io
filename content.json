{"meta":{"title":"BIBOBOBIBOBI","subtitle":null,"description":null,"author":"BIBOBOBIBOBI","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-07-23T03:56:24.000Z","updated":"2018-07-23T04:21:16.843Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-23T04:23:23.000Z","updated":"2018-07-23T04:29:24.325Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"嵌入式LINUX下CGI与HTML网页之间的通信","slug":"cgi-html","date":"2018-08-15T07:04:34.000Z","updated":"2018-08-15T08:40:02.012Z","comments":true,"path":"1522571396/","link":"","permalink":"http://yoursite.com/1522571396/","excerpt":"","text":"前言CGI 是Web服务器运行时外部程序的规范, 按CGI编写的程序可以扩展服务器功能. CGI应用程序能与浏览器进行交互, 还可通过数据库API与数据库服务器等外部数据源进行通信, 从数据库服务器中获取数据.几乎所有服务器都支持CGI,可用任何语言编写CGI,包括C/C++, Python, Shell等.本文通过编写一个简单的登录的用例来了解CGI与HTML如何互相传递参数. 要在CGI和HTML之间传递数据, 需要移植CGI库, 由于比较简单这里就不再赘述, 本文默认已经移植好了CGI库以及能在开发板上使用httpd服务搭建Web服务器.HTML调用CGI并传递参数在HTML中我们使用表单(from), 采集和提交用户输入信息, 然后调用CGI程序处理:[src]www/index.html1234567...&lt;form action=\"/cgi-bin/getresult_cgi.cgi\" method=\"POST\"&gt; &lt;input type=\"text\" name=\"Username\" placeholder=\"User\" required=\"required\" /&gt; &lt;input type=\"password\" name=\"Password\" placeholder=\"Passwd\" required=\"required\" /&gt; &lt;button type=\"submit\"&gt; Login &lt;/button&gt;&lt;/form&gt;...Tipsaction为处理表单请求的程序;method表示发送表单信息的方式. method有两个值: GET和POST. GET是把参数数据队列加到提交表单的ACTION属性所指的URL中, 值和表单内各个字段一一对应, 在URL中可以看到; POST是通过HTTP POST机制, 将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址, 用户看不到这个过程. GET一般用于取得和显示数据; POST多用于数据的保存更新;我们来看看CGI程序中是如何接受传递的参数. 首先是获取请求方式, 根据请求方式去拿数据:[src]getresult_cgi.c1234567int main(void)&#123; ... req_method = getenv(\"REQUEST_METHOD\"); input = getcgidata(stdin, req_method); ...&#125;来看下解析数据关键代码:[src]getresult_cgi.c1234567891011121314151617char* getcgidata(FILE* fp, char* requestmethod)&#123; ... if (!strcmp(requestmethod, \"GET\")) &#123; input = getenv(\"QUERY_STRING\"); ... &#125; else if (!strcmp(requestmethod, \"POST\")) &#123; len = atoi(getenv(\"CONTENT_LENGTH\")); input = (char*)malloc(sizeof(char)*(size + 1)); ... while(1) &#123; input[i] = (char)fgetc(fp); ... &#125; &#125; ...&#125;可以看出GET请求传递的参数保存在环境变量QUERY_STRING中, 而POST请求将传递的参数保存在标准输入(stdin)中; 然后开始解析字符串:src:getresult_cgi.c123456int main(void)&#123; ... sscanf(input, \"%*[^=]=%[^&amp;]%*[^=]=%[^EOF]\", name, pass); ...&#125;这里使用sscanf来提取用户名和密码, 从HTML传递过来的参数格式应为:1Username=admin&amp;Password=aaaaasscanf中格式化字符串的含义为:12%*[^=]=%[^&amp;]: 读取‘=’和‘&amp;’之间的字符, 放到name中;%*[^=]=%[^EOF]: 读取‘=’到文件流结尾之前的字符, 放到pass中;至此, 已经将HTML传递过来的参数解析完毕;CGI返回数据给HTML本文要做的是根据用户名和密码正不正确来返回不同信息: 正确返回login success信息, 错误返回输入的用户名和密码. 要将CGI数据传给HTML, 可以在CGI程序中直接生成一个页面, 不过这样好像不够灵活, 那么就使用HTML页面跳转时用来传递数据的Cookie来实现CGI与HTML间数据的传递:[src]getresult_cgi.c12345678910111213int main(void) ... if (!strncmp(name, \"root\", 4) &amp;&amp; !strncmp(pass, \"000\", 3))&#123; printf(\"Set-Cookie: %s=%s; path=/\\r\\n\",\"Result\",\"login success\"); printf(\"%s%c%c\\n\",\"Content-Type:text/html;charset=utf-8\",13,10); printf(\"&lt;meta http-equiv=\\\"refresh\\\" content=\\\"0;url=../result.html\\\"&gt;\"); &#125; else &#123; printf(\"Set-Cookie: %s=%s&amp;&amp;%s; path=/\\r\\n\",\"Result\", name, pass); printf(\"%s%c%c\\n\",\"Content-Type:text/html;charset=utf-8\",13,10); printf(\"&lt;meta http-equiv=\\\"refresh\\\" content=\\\"0;url=../result.html\\\"&gt;\"); &#125; ...&#125;这里要注意的是要先设置Cookie后再输出http请求头, 否则Cookie无效. 接着我们看看HTML是怎么接受Cookie的:[src]www/result.html12345678910...&lt;form&gt; Login Result= &lt;input name=\"lignt_now\" type=\"text\" id=\"result_text\" /&gt;&lt;/form&gt;&lt;script type=\"text/javascript\" &gt; cookie_text= document.getElementById('result_text'); cookie_text.value =getCookie('Result')&lt;/script&gt;...这里使用了一个表单, 表单内有一个文本框, 内容由javascript来填充; 我们再来看看getCookie()做了什么:[src]www/result.html12345678910111213141516171819...&lt;script type=\"text/javascript\" &gt;function getCookie(c_name)&#123; if (document.cookie.length&gt;0) &#123; c_start=document.cookie.indexOf(c_name + \"=\") if (c_start!=-1) &#123; c_start=c_start + c_name.length+1 c_end=document.cookie.indexOf(\";\",c_start) if (c_end==-1) c_end=document.cookie.length return unescape(document.cookie.substring(c_start,c_end)) &#125; &#125; return \"\"&#125;&lt;/script&gt;...前面我们传递的Cookie为“Result=login success”或“Result=username, password”. 在javascript中根据首尾字符使用document.cookie.indexOf()来获取Cookie有效内容的开始和结束位置, 然后根据字符开始和结束位置使用document.cookie.substring()读取子字符串, 最终得到需要的数据.详细代码这里把所有代码都贴出来,首先是CGI程序:[src]getresult_cgi.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;string.h&gt;#include &lt;iconv.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include \"cgi.h\"#include \"aux.h\"char* getcgidata(FILE* fp, char* requestmethod)&#123; char* input; int len; int size = 1024; int i = 0; if (!strcmp(requestmethod, \"GET\")) &#123; input = getenv(\"QUERY_STRING\"); return input; &#125; else if (!strcmp(requestmethod, \"POST\")) &#123; len = atoi(getenv(\"CONTENT_LENGTH\")); input = (char*)malloc(sizeof(char)*(size + 1)); if (len == 0) &#123; input[0] = '\\0'; return input; &#125; while(1) &#123; input[i] = (char)fgetc(fp); if (i == size) &#123; input[i+1] = '\\0'; return input; &#125; --len; if (feof(fp) || (!(len))) &#123; i++; input[i] = '\\0'; return input; &#125; ++i; &#125; &#125; return NULL;&#125;int main(void)&#123; char *input; char *req_method; char name[32]; char pass[32]; req_method = getenv(\"REQUEST_METHOD\"); input = getcgidata(stdin, req_method); /* Format: Username=admin&amp;Password=aaaaa. */ //sscanf(input, \"%*[^=]=%*c%[^&amp;]%*[^=]%*c%[^\\n]\", name, pass); sscanf(input, \"%*[^=]=%[^&amp;]%*[^=]=%[^EOF]\", name, pass); if (!strncmp(name,\"root\",4) &amp;&amp; !strncmp(pass, \"000\", 3))&#123; /* Set Cookie. */ printf(\"Set-Cookie: %s=%s; path=/\\r\\n\",\"Result\",\"login success\"); printf(\"%s%c%c\\n\",\"Content-Type:text/html;charset=utf-8\",13,10); printf(\"&lt;meta http-equiv=\\\"refresh\\\" content=\\\"0;url=../result.html\\\"&gt;\"); &#125; else &#123; printf(\"Set-Cookie: %s=%s&amp;&amp;%s; path=/\\r\\n\",\"Result\", name, pass); printf(\"%s%c%c\\n\",\"Content-Type:text/html;charset=utf-8\",13,10); printf(\"&lt;meta http-equiv=\\\"refresh\\\" content=\\\"0;url=../result.html\\\"&gt;\"); &#125; return 0;&#125;主页index.html:[src]www/index.html12345678910111213&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt; Login &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/cgi-bin/getresult_cgi.cgi\" method=\"POST\"&gt; &lt;input type=\"text\" name=\"Username\" placeholder=\"User\" required=\"required\" /&gt; &lt;input type=\"password\" name=\"Password\" placeholder=\"Passwd\" required=\"required\" /&gt; &lt;button type=\"submit\"&gt; Login &lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;返回结果result.html:[src]www/result.html123456789101112131415161718192021222324252627282930313233&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;script type=\"text/javascript\" &gt;function getCookie(c_name)&#123; if (document.cookie.length&gt;0) &#123; c_start=document.cookie.indexOf(c_name + \"=\") if (c_start!=-1) &#123; c_start=c_start + c_name.length+1 c_end=document.cookie.indexOf(\";\",c_start) if (c_end==-1) c_end=document.cookie.length return unescape(document.cookie.substring(c_start,c_end)) &#125; &#125; return \"\"&#125;&lt;/script&gt;&lt;title&gt;Result&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; Login Result= &lt;input name=\"lignt_now\" type=\"text\" id=\"result_text\" /&gt;&lt;/form&gt;&lt;script type=\"text/javascript\" &gt; bang_text= document.getElementById('result_text'); bang_text.value =getCookie('Result')&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;参考文章嵌入式CGI 与HTML的数据交换CGI编程","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/categories/嵌入式/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/tags/嵌入式/"},{"name":"cgi","slug":"cgi","permalink":"http://yoursite.com/tags/cgi/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"ZYNQ从BUSYBOX开始制作RAMDISK","slug":"zynq-ramdisk","date":"2018-08-13T10:14:25.000Z","updated":"2018-08-15T08:30:43.810Z","comments":true,"path":"2391800641/","link":"","permalink":"http://yoursite.com/2391800641/","excerpt":"","text":"Busybox移植BusyBox将许多具有共性的小版本的UNIX工具结合到一个单一的可执行文件. 这样的集合可以替代大部分常用工具, BusyBox提供了一个比较完善的环境，可以适用于任何小的嵌入式系统.这篇文章将从移植Busybox开始, 一步一步制作一个属于自己的根文件系统.下载Busybox的官方源码下载路径为: 点我本次下载的是busybox-1.29.1.tar.bz2配置解压下载的文件, 进入到源码根目录:1$ tar xvf busybox-1.29.1.tar.bz2 &amp;&amp; cd busybox-1.29.1先使用默认配置:1$ make deconfig然后输入命令进行配置:1$ make menuconfig配置以下选项:1234Settings ---&gt; [ ] Don't use /usr [ ] Build static binary (no shared libs) (arm-linux-gnueabihf-) Cross compiler prefix第一个是选择是否编译出/usr相关目录, 这里不勾选则生成/usr目录;第二个是选择静态编译不依赖动态库, 制作根文件系统后面会拷贝一套动态连接库, 先不勾选;第三个是配置交叉编译工具, 根据实际情况填写;其他的需要的命令支持自行选择配置.Tips静态编译与动态编译的区别动态编译的可执行文件需要附带一个的动态链接库, 在执行时, 需要调用其对应动态链接库中的命令. 所以其优点一方面是缩小了执行文件本身的体积, 另一方面是加快了编译速度, 节省了系统资源. 缺点一是哪怕是很简单的程序, 只用到了链接库中的一两条命令, 也需要附带一个相对庞大的链接库; 二是如果其他计算机上没有安装对应的运行库, 则用动态编译的可执行文件就不能运行.静态编译就是编译器在编译可执行文件的时候, 将可执行文件需要调用的对应动态链接库(.so)中的部分提取出来, 链接到可执行文件中去, 使可执行文件在运行的时候不依赖于动态链接库. 所以其优缺点与动态编译的可执行文件正好互补.编译1$ make &amp;&amp; make install生成文件位于_install文件夹内:12$ ls _install/bin linuxrc sbin usr拷贝lib库新建一个root目录, 进入该目录下:1$ mkdir root &amp;&amp; cd root/将编译busybox生成的目录下的所有文件拷贝过去:1$ cp -af ../busybox-1.29.1/_install/* .创建其他的目录1$ mkdir dev etc lib sys proc tmp var home root mnt拷贝lib库整个lib库有很多, 全部拷贝玩的话就有点臃肿了, 下面是我参考官方的ramdisk里面的lib库拷贝的, 应该还可以再精简, 先凑合着用吧:1234567891011121314$ ls lib/ld-2.25.so libcidn-2.25.so libgfortran.so.4 libnss_compat-2.25.so libnss_nis.so.2 libstdc++.so.6ld-linux-armhf.so.3 libcidn.so.1 libgfortran.so.4.0.0 libnss_compat.so.2 libpcprofile.so libstdc++.so.6.0.24libanl-2.25.so libcilkrts.so libgomp.so libnss_db-2.25.so libpthread-2.25.so libstdc++.so.6.0.24-gdb.pylibanl.so.1 libcilkrts.so.5 libgomp.so.1 libnss_db.so.2 libpthread.so.0 libthread_db-1.0.solibasan.so libcilkrts.so.5.0.0 libgomp.so.1.0.0 libnss_dns-2.25.so libresolv-2.25.so libthread_db.so.1libasan.so.4 libcrypt-2.25.so libitm.so libnss_dns.so.2 libresolv.so.2 libubsan.solibasan.so.4.0.0 libcrypt.so.1 libitm.so.1 libnss_files-2.25.so librt-2.25.so libubsan.so.0libatomic.so libc.so.6 libitm.so.1.0.0 libnss_files.so.2 librt.so.1 libubsan.so.0.0.0libatomic.so.1 libdl-2.25.so libm-2.25.so libnss_hesiod-2.25.so libSegFault.so libutil-2.25.solibatomic.so.1.2.0 libdl.so.2 libmemusage.so libnss_hesiod.so.2 libssp.so libutil.so.1libBrokenLocale-2.25.so libgcc_s.so libm.so.6 libnss_nis-2.25.so libssp.so.0libBrokenLocale.so.1 libgcc_s.so.1 libnsl-2.25.so libnss_nisplus-2.25.so libssp.so.0.0.0libc-2.25.so libgfortran.so libnsl.so.1 libnss_nisplus.so.2 libstdc++.so接下来拷贝上面的运行库:1$ cp -af /opt/toolchain/arm-linux-gnueabihf/arm-linux-gnueabihf/libc/lib/*.so* lib/Tips各个交叉编译工具的运行库的所在位置可能不同;部分库文件是符号链接, 要保留原文件属性的前提下复制文件请使用 cp -a 命令;然后去掉库文件的符号表和调试信息进行瘦身, 进一步减少空间占用:1$ arm-linux-gnueabihf-strip lib/*现在整个可执行命令以及运行库已移植完成, 接下来是启动添加配置文件.启动配置文件profile文件新建etc/profile文件, 并添加以下内容:[src]etc/profile123456789#!/bin/shexport HOSTNAME=skycasterexport USER=rootexport HOME=homeexport PS1=\"[$USER@$HOSTNAME \\W]\\# \"PATH=/bin:/sbin:/usr/bin:/usr/sbinLD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATHexport PATH LD_LIBRARY_PATHinittab文件新建etc/inittab文件, 并添加以下内容:[src]etc/inittab123456789#this is run first except when booting in single-user mode. ::sysinit:/etc/init.d/rcS# /bin/sh invocations on selected ttys# start an &quot;askfirst&quot; shell on the console (whatever that may be)::askfirst:-/bin/sh# stuff to do when restarting the init process::restart:/sbin/init# stuff to do before rebooting::ctrlaltdel:/sbin/rebootfstab文件新建etc/fstab文件, 并添加以下内容:[src]etc/fstab12345LABEL=/ / tmpfs defaults 0 0none /dev/pts devpts gid=5,mode=620 0 0none /proc proc defaults 0 0none /sys sysfs defaults 0 0none /tmp tmpfs defaults 0 0rcS文件新建etc/init.d/rcS文件, 并添加以下内容:[src]etc/init.d/rcS12345678910111213141516171819#!/bin/shecho \"Starting rcS...\"echo \"++ Mounting filesystem\"mount -t proc none /procmount -t sysfs none /sysmount -t tmpfs none /tmpecho \"++ Setting up mdev\"echo /sbin/mdev &gt; /proc/sys/kernel/hotplugmdev -smkdir -p /dev/ptsmkdir -p /dev/i2cmount -t devpts devpts /dev/ptsecho \"rcS Complete\"为其添加执行权限和所属用户组:12$ chmod 755 etc/init.d/rcS$ sudo chown root:root etc/init.d/rcSpasswd文件新建etc/passwd文件, 并添加以下内容:[src]etc/passwd1root:$1$qC.CEbjC$SVJyqm.IG.gkElhaeM.FD0:0:0:root:/root:/bin/sh现在根文件系统已经制作完成, 接下来就要制作成ramdisk image.制作ramdisk制作新的ramdisk.image文件系统格式为ext2, 大小为16M:1234$ dd if=/dev/zero of=ramdisk.image bs=1024 count=16384$ mke2fs -F ramdisk.image -L \"ramdisk\" -b 1024 -m 0$ tune2fs ramdisk.image -i 0$ chmod 777 ramdisk.image挂载ramdisk新建一个rootfs目录, 并将ramdisk.image挂载到rootfs目录:123$ mkdir rootfs$ chmod u+rwx ramdisk.image$ sudo mount -o loop ramdisk.image rootfs将制作好的根文件系统全部拷贝到rootfs目录下:1$ cp -af root/* rootfs/*打包ramdisk卸载rootfs, 并打包ramdisk.image:123$ sudo umount rootfs$ gzip ramdisk.image$ mkimage -A arm -T ramdisk -C gzip -d ramdisk.image.gz uramdisk.image.gz使用将ramdisk.image.gz拷贝到/mnt/workspace/linux/output目录下, 执行:1$ mk_kernel.sh &amp;&amp; mk_sdimage.sh将/mnt/workspace/linux/images/sd_image目录下的生成文件拷贝到SD卡, 重新上电, 启动后如下:123456[root@skycaster ]# pwd/[root@skycaster ]# lsbin home mnt sbin usrdev lib proc sys varetc lost+found root tmp测试环境@系统: Windows 7 Professional with SP1@Vivado: 2015.04@虚拟机: OSRC_Miz7_ubuntu_14@开发板: 米联MIZ702N参考文章(原创)一步一步学ZedBoard &amp; Zynq(七)：制作ZedBoard上linux根文件系统(ramdisk)最新busybox-1.28.1制作根文件系统","categories":[{"name":"xilinx","slug":"xilinx","permalink":"http://yoursite.com/categories/xilinx/"}],"tags":[{"name":"xilinx","slug":"xilinx","permalink":"http://yoursite.com/tags/xilinx/"},{"name":"ramdisk","slug":"ramdisk","permalink":"http://yoursite.com/tags/ramdisk/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"ZYNQ 烧录QSPI FLASH及从QSPI启动","slug":"zynq-qspi-02","date":"2018-08-06T06:21:41.000Z","updated":"2018-08-15T08:23:48.320Z","comments":true,"path":"622008616/","link":"","permalink":"http://yoursite.com/622008616/","excerpt":"","text":"ZYNQ Linux启动方式由于ZYNQ采用的是PS(ARM A9双核)+PL(FPGA)设计, 整个启动过程比较复杂, 因此我们从嵌入式Linux软件层面的角度考虑, 将ZYNQ当作一块纯ARM开发板, 从而简化ZYNQ的启动流程.SD卡和QSPI启动流程ZYNQ跑Linux系统, 在实际情况中用得比较多的启动方法为SD卡启动和QSPI启动, 先看下这两种方式的启动流程:QSPI启动123456设置板子为QSPI启动 ----&gt; 上电启动 ---&gt; 从Flash加载BOOT.bin(fsbl.elf, system.bit, u-boot.elf) ---&gt; 进入U-BOOT ---&gt; 解析bootargs(将kernel, devicetree, ramdisk 从Flash加载到内存指定地址) ---&gt; 使用bootm命令启动LinuxSD卡启动123456设置板子为SD卡启动 ----&gt; 上电启动 ---&gt; 从SD卡加载BOOT.bin(fsbl.elf, system.bit, u-boot.elf) ---&gt; 进入U-BOOT ---&gt; 解析bootargs(将kernel, devicetree, ramdisk 从SD卡加载到内存指定地址) ---&gt; 使用bootm命令启动LinuxSD卡和QSPI启动Linux的bootargsU-boot中这两种启动方式的boottargs定义:[src]bootloader/include/configs/zynq-common.h12345678910111213141516171819202122232425262728293031...\"kernel_image=uImage\\0\" \\\"kernel_load_address=0x2080000\\0\" \\\"ramdisk_image=uramdisk.image.gz\\0\" \\\"ramdisk_load_address=0x4000000\\0\" \\\"devicetree_image=devicetree.dtb\\0\" \\\"devicetree_load_address=0x2000000\\0\" \\\"bitstream_image=system.bit.bin\\0\" \\\"boot_image=BOOT.bin\\0\" \\...\"kernel_size=0x500000\\0\" \\\"devicetree_size=0x20000\\0\" \\\"ramdisk_size=0x800000\\0\"...\"qspiboot=echo Copying Linux from QSPI flash to RAM... &amp;&amp; \" \\ \"sf probe 0 0 0 &amp;&amp; \" \\ \"sf read $&#123;kernel_load_address&#125; 0x500000 $&#123;kernel_size&#125; &amp;&amp; \" \\ \"sf read $&#123;devicetree_load_address&#125; 0xA00000 $&#123;devicetree_size&#125; &amp;&amp; \" \\ \"echo Copying ramdisk... &amp;&amp; \" \\ \"sf read $&#123;ramdisk_load_address&#125; 0xA20000 $&#123;ramdisk_size&#125; &amp;&amp; \" \\ \"bootm $&#123;kernel_load_address&#125; $&#123;ramdisk_load_address&#125; $&#123;devicetree_load_address&#125;\\0\" \\...\"sdboot=if mmcinfo; then \" \\ \"run uenvboot; \" \\ \"echo Copying Linux from SD to RAM... &amp;&amp; \" \\ \"load mmc 0 $&#123;kernel_load_address&#125; $&#123;kernel_image&#125; &amp;&amp; \" \\ \"load mmc 0 $&#123;devicetree_load_address&#125; $&#123;devicetree_image&#125; &amp;&amp; \" \\ \"load mmc 0 $&#123;ramdisk_load_address&#125; $&#123;ramdisk_image&#125; &amp;&amp; \" \\ \"bootm $&#123;kernel_load_address&#125; $&#123;ramdisk_load_address&#125; $&#123;devicetree_load_address&#125;; \" \\ \"fi\\0\" \\...分别看下u-boot中sf和load命令:12345678// sf: 用于spi/qspi flash的读/写/擦除操作;// read/write/erase之前必须先调用sf probe;// 具体用法:sf probe [[bus:]cs] [hz] [mode] - init flash device on given SPI bus and chip selectsf read addr offset len - read `len' bytes starting at`offset' to memory at `addr'sf write addr offset len - write `len' bytes from memor at `addr' to flash at `offset'sf erase offset [+]len - erase `len' bytes from `offset' `+len' round up `len' to block sizesf update addr offset len - erase and write `len' bytes from memory at `addr' to flash at `offset'12345678910// load: 用于读取文件系统中的二进制文件;// 从SD卡启动, mmc 0 为SD卡;// 具体用法:load &lt;interface&gt; [&lt;dev[:part]&gt; [&lt;addr&gt; [&lt;filename&gt; [bytes [pos]]]]] - Load binary file 'filename' from partition 'part' on device type 'interface' instance 'dev' to address 'addr' in memory. 'bytes' gives the size to load in bytes. If 'bytes' is 0 or omitted, the file is read until the end. 'pos' gives the file byte position to start reading from. If 'pos' is 0 or omitted, the file is read from the start.通过对比我们可以看出SD卡和QSPI启动Linux的区别主要在于:前者从SD卡中将uImage, uramdisk.image.gz, devicetree.dtb文件加载到内存指定位置, 而后者从qspi flash 指定地址(分区)中加载到内存.Tips:qspiboot中读取Flash时使用的三个地址偏移0x500000, 0xA00000, 0xA20000, 需要根据实际情况进行配置.QSPI FLASH烧录U-boot下烧录SD卡启动文件到QSPI Flash设置板子为SD卡启动, 上电后进入U-boot命令行:123456789101112131415161718Zynq&gt; ls mmc 0 # 查看SD卡目录结构;Zynq&gt; sf probe 0 0 0 # 初始化SPI FLASH Zynq&gt; fatload mmc 0 0x08000000 BOOT.bin # 从SD卡加载BOOT.bin到内存地址0x08000000;Zynq&gt; sf erase 0x0 0x500000 # 擦除Flash 0x0地址处大小为0x500000的空间;Zynq&gt; sf write 0x8000000 0x0 0x500000 # 将内存地址0x08000000起始处的0x500000的大小内容写进Flash地址0x0处; Zynq&gt; fatload mmc 0 0x08000000 uImage # 从SD卡加载uImage到内存地址0x08000000;Zynq&gt; sf erase 0x500000 0x500000 # 擦除Flash 0x500000地址处大小为0x500000的空间;Zynq&gt; sf write 0x8000000 0x500000 0x500000 # 将内存地址0x08000000起始处的0x500000的大小内容写进Flash地址0x500000处; Zynq&gt; fatload mmc 0 0x08000000 devicetree.dtb # 从SD卡加载devicetree.dtb到内存地址0x08000000;Zynq&gt; sf erase 0xA00000 0x20000 # 擦除Flash 0xA00000地址处大小为0x20000的空间;Zynq&gt; sf write 0x8000000 0xA00000 0x20000 # 将内存地址0x08000000起始处的0x20000的大小内容写进Flash地址0xA00000处; Zynq&gt; fatload mmc 0 0x08000000 uramdisk.image.gz # 从SD卡加载uramdisk.image.gz到内存地址0x08000000;Zynq&gt; sf erase 0xA20000 0x800000 # 擦除Flash 0xA20000地址处大小为0x500000的空间;Zynq&gt; sf write 0x8000000 0xA20000 0x800000 # 将内存地址0x08000000起始处的0x800000的大小内容写进Flash地址0xA20000处;设置板子为QSPI启动, 重新上电, 成功进入系统.制作QSPI启动镜像直接烧写SD卡启动文件似乎有点复杂, 那么我们就制作单独的QSPI启动镜像文件, 简化烧录过程; 首先我们看看制作SD卡启动文件脚本的主要内容:scripts/mk_sd_image.sh123456789101112131415...echo \"//arch = zynq; split = false; format = BIN\" &gt; $&#123;TARGET&#125;/sd_image.bifecho \"the_ROM_image:\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \"&#123;\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \" [bootloader]$&#123;TARGET&#125;/fsbl.elf\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \" $&#123;TARGET&#125;/system_wrapper.bit\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \" $&#123;TARGET&#125;/u-boot.elf\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \"&#125;\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bif...bootgen -image $&#123;TARGET&#125;/sd_image.bif -o $&#123;IMAGES&#125;/sd_image/BOOT.bin -w on...cp -a $&#123;TARGET&#125;/uImage $&#123;IMAGES&#125;/sd_image/cp -a $&#123;TARGET&#125;/devicetree.dtb $&#123;IMAGES&#125;/sd_image/cp -a $&#123;TARGET&#125;/uramdisk.image.gz $&#123;IMAGES&#125;/sd_image/...从这一段内容可以看出BOOT.bin是由sd_image.bif打包生成的; 而sd_image.bif是由fsbl.elf, system_wrapper.bit, boot.elf三个文件组成, 基本格式为:123456the_ROM_image:&#123; [bootloader]fsbl.elf system_wrapper.bit boot.elf&#125;剩下的uImage, devicetree.dtb, uramdisk.image.gz则是直接拷贝过来的; 那么我们将bif文件的格式加入偏移后变成:123456789the_ROM_image:&#123; [bootloader]fsbl.elf system_wrapper.bit boot.elf [offset = 0x500000]uImage.bin [offset = 0xA00000]devicetree.dtb [offset = 0xA20000]uramdisk.image.gz&#125;这样就将所有需要的启动文件打包成一个文件.Tips:注意这里的offset要与bootargs中的偏移一致才能正确读取各个部分内容.修改mk_sd_image.sh的内容, 保存为mk_qspi_image.sh[src]scripts/mk_qspi_image.sh12345678910111213141516171819202122232425...BIF_FILE=$&#123;TARGET&#125;/qspi_image.bif# startecho \"//arch = zynq; split = false; format = BIN\" &gt; $&#123;BIF_FILE&#125;echo \"the_ROM_image:\" &gt;&gt;$&#123;BIF_FILE&#125;echo \"&#123;\" &gt;&gt;$&#123;BIF_FILE&#125;# The files we need are:# 1. the first stage boot loaderecho \" [bootloader]$&#123;TARGET&#125;/fsbl.elf\" &gt;&gt;$&#123;BIF_FILE&#125;# 2. FPGA bit streamif [ -f \"$&#123;TARGET&#125;/system_wrapper.bit\" ]; then echo \" $&#123;TARGET&#125;/system_wrapper.bit\" &gt;&gt;$&#123;BIF_FILE&#125;fi# 3. Das U-Boot boot loaderecho \" $&#123;TARGET&#125;/u-boot.elf\" &gt;&gt;$&#123;BIF_FILE&#125;# 4. Linux kernel with modified header for U-Bootecho \" [offset = 0x500000]$&#123;TARGET&#125;/uImage.bin\" &gt;&gt;$&#123;BIF_FILE&#125;# 5. Device tree blobecho \" [offset = 0xA00000]$&#123;TARGET&#125;/devicetree.dtb\" &gt;&gt;$&#123;BIF_FILE&#125;# 6. Root filesystemecho \" [offset = 0xA20000]$&#123;TARGET&#125;/uramdisk.image.gz\" &gt;&gt;$&#123;BIF_FILE&#125;echo \"&#125;\" &gt;&gt;$&#123;BIF_FILE&#125;# endbootgen -image $&#123;TARGET&#125;/qspi_image.bif -o $&#123;IMAGES&#125;/qspi_image/qspi_image.bin -w on...执行以下脚本生成image/qspi_image/qspi_image.bin, 文件大小接近18MB.1# mk_bootloader.sh &amp;&amp; mk_kernel.sh &amp;&amp; mk_qspi_image.sh烧录时执行以下命令即可:123Zynq&gt; fatload mmc 0 0x08000000 qspi_image.bin # 从SD卡加载qspi_image.bin到内存地址0x08000000;Zynq&gt; sf erase 0x0 0x1200000 # 擦除Flash 0x0地址处大小为0x1200000的空间;Zynq&gt; sf write 0x8000000 0x0 0x1200000 # 将内存地址0x08000000起始处的0x1200000的大小内容写进Flash地址0x0处;启动Linux后烧录启动文件到QSPI Flash在Linux下可以将bin文件通过dd 命令直接写进Flash中. 首先要配置QSPI Flash驱动, 生成MTD设备节点. 在Kernel源码路径输入命令:1# make ARCH=arm menuconfig选择以下配置选项:12345678Device Drivers ---&gt; &lt;*&gt; Memory Technology Device (MTD) support ---&gt; Self-contained MTD device drivers ---&gt; &lt;*&gt; Support most SPI Flash chips (AT26DF, M25P, W25X, ...) &lt;*&gt; SPI-NOR device support ---&gt; [*] SPI support ---&gt; &lt;*&gt; Xilinx SPI controller common module &lt;*&gt; Xilinx Zynq QSPI controller修改设备树:[src]kernel/arch/arm/boot/dts/zynq-zed.dts12345678910111213141516171819202122 ... aliases &#123; ... spi0 = &amp;qspi; ... &#125;; ...&amp;qspi &#123; status = &quot;okay&quot;; is-dual = &lt;0&gt;; num-cs = &lt;1&gt;; flash@0 &#123; compatible = &quot;n25q128a11&quot;; reg = &lt;0x0&gt;; spi-tx-bus-width = &lt;1&gt;; spi-rx-bus-width = &lt;4&gt;; spi-max-frequency = &lt;50000000&gt;; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; &#125;;&#125;;...在flash子节点下可以自己添加分区, 格式为[src]kernel/arch/arm/boot/dts/zynq-zed.dts12345678910111213141516partition@qspi-fsbl-uboot &#123; label = &quot;qspi-fsbl-uboot&quot;; reg = &lt;0x0 0x500000&gt;;&#125;;partition@qspi-linux &#123; label = &quot;qspi-linux&quot;; reg = &lt;0x500000 0x500000&gt;;&#125;;partition@qspi-device-tree &#123; label = &quot;qspi-device-tree&quot;; reg = &lt;0xA00000 0x20000&gt;; &#125;;partition@qspi-rootfs &#123; label = &quot;qspi-rootfs&quot;; reg = &lt;0xA20000 0x800000&gt;;&#125;;执行以下脚本生成qspi_image.bin:1# mk_bootloader.sh &amp;&amp; mk_kernel.sh &amp;&amp; mk_qspi_image.sh拷贝生成文件到SD卡, 上电启动, 进入系统, 查看设备节点和MTD分区信息:12345# ls /dev/mtd*/dev/mtd0 /dev/mtd0ro /dev/mtdblock0# cat /proc/mtd dev: size erasesize namemtd0: 02000000 00010000 &quot;spi0.0&quot;使用dd命令烧录QSPI Flash:123# dd if=&lt;sdcard_root_dir&gt;/qspi_image.bin of=/dev/mtdblock0 bs=102417687+1 records in17687+1 records out重新启动开发板, 进入系统, OK.测试环境@系统: Windows 7 Professional with SP1@Vivado: 2015.04@虚拟机: OSRC_Miz7_ubuntu_14@开发板: 米联MIZ702N参考文章[移植篇] CH04 LINUX从QSPI启动","categories":[{"name":"xilinx","slug":"xilinx","permalink":"http://yoursite.com/categories/xilinx/"}],"tags":[{"name":"xilinx","slug":"xilinx","permalink":"http://yoursite.com/tags/xilinx/"},{"name":"qspi","slug":"qspi","permalink":"http://yoursite.com/tags/qspi/"}]},{"title":"ZYNQ QSPI驱动分析","slug":"zynq-qspi-01","date":"2018-08-03T03:52:41.000Z","updated":"2018-08-15T08:12:15.074Z","comments":true,"path":"1064320173/","link":"","permalink":"http://yoursite.com/1064320173/","excerpt":"","text":"ZYNQ QSPI框架接口12345678910111213----------------|------------------------------------------------------------MTD Sub System |----------------|------------------------------------------------------------ | spi_nor_read spi_nor_write spi_nor_lock spi_nor_unlockSPI Nor |------------------------------------------------------------ | m25p80_write m25p80_read m25p80_write_reg m25p80_read_reg----------------|------------------------------------------------------------SPI Bus | spi_write spi_sync spi_write_then_read----------------|------------------------------------------------------------SPI Master | zynq_qspi_setup zynq_qspi_start_transfer----------------|------------------------------------------------------------Hardware |----------------|------------------------------------------------------------ZYNQ QSPI驱动注册过程SPI MASTER 驱动注册在驱动入口函数zynq_qspi_probe中, 完成对QSPI Controller的一系列初始化[src]driver/spi/spi-zynq-qspi.c123456789101112static int zynq_qspi_probe(struct platform_device *pdev)&#123; ... /* QSPI controller initializations */ zynq_qspi_init_hw(xqspi); ... master-&gt;setup = zynq_qspi_setup; master-&gt;set_cs = zynq_qspi_chipselect; master-&gt;transfer_one = zynq_qspi_start_transfer; master-&gt;prepare_transfer_hardware = zynq_prepare_transfer_hardware; ...&#125;最后调用spi_register_master()创建设备节点/dev/spiX.X[src]driver/spi/spi-zynq-qspi.c12345678910static int zynq_qspi_probe(struct platform_device *pdev)&#123; ... ret = spi_register_master(master); if (ret) &#123; dev_err(&amp;pdev-&gt;dev, \"spi_register_master failed\\n\"); goto clk_dis_all; &#125; ...&#125;SPI BUS 驱动注册在spi_register_master函数的最后, 调用了of_register_spi_device来遍历子节点[src]driver/spi/spi.c1234567int spi_register_master(struct spi_master *master)&#123; ... /* Register devices from the device tree and ACPI */ of_register_spi_devices(master); ...&#125;在该函数中读取设备树上的配置信息, 初始化SPI BUS[src]driver/spi/spi.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static void of_register_spi_devices(struct spi_master *master)&#123; ... /* Alloc an spi_device */ spi = spi_alloc_device(master); ... /* Select device driver */ rc = of_modalias_node(nc, spi-&gt;modalias, sizeof(spi-&gt;modalias)); ... /* Device address */ rc = of_property_read_u32(nc, \"reg\", &amp;value); spi-&gt;chip_select = value; ... /* Mode (clock phase/polarity/etc.) */ if (of_find_property(nc, \"spi-cpha\", NULL)) spi-&gt;mode |= SPI_CPHA; if (of_find_property(nc, \"spi-cpol\", NULL)) spi-&gt;mode |= SPI_CPOL; if (of_find_property(nc, \"spi-cs-high\", NULL)) spi-&gt;mode |= SPI_CS_HIGH; if (of_find_property(nc, \"spi-3wire\", NULL)) spi-&gt;mode |= SPI_3WIRE; if (of_find_property(nc, \"spi-lsb-first\", NULL)) spi-&gt;mode |= SPI_LSB_FIRST; /* Device DUAL/QUAD mode */ if (!of_property_read_u32(nc, \"spi-tx-bus-width\", &amp;value)) &#123; switch (value) &#123; case 1: break; case 2: spi-&gt;mode |= SPI_TX_DUAL; break; case 4: spi-&gt;mode |= SPI_TX_QUAD; break; default: dev_warn(&amp;master-&gt;dev, \"spi-tx-bus-width %d not supported\\n\", value); break; &#125; &#125; if (!of_property_read_u32(nc, \"spi-rx-bus-width\", &amp;value)) &#123; switch (value) &#123; case 1: break; case 2: spi-&gt;mode |= SPI_RX_DUAL; break; case 4: spi-&gt;mode |= SPI_RX_QUAD; break; default: dev_warn(&amp;master-&gt;dev, \"spi-rx-bus-width %d not supported\\n\", value); break; &#125; &#125; /* Device speed */ rc = of_property_read_u32(nc, \"spi-max-frequency\", &amp;value); spi-&gt;max_speed_hz = value; ...&#125;SPI NOR 驱动注册在of_register_spi_device函数的最后, 调用spi_add_device来加载m25p80设备驱动[src]driver/spi/spi.c1234567static void of_register_spi_devices(struct spi_master *master)&#123; ... /* Register the new device */ rc = spi_add_device(spi); ...&#125;在m25p_probe函数中, 配置spi nor的read/write(读写nor flash), read_reg(配置qspi寄存器), write_reg(配置nor flash寄存器)[src]drivers/mtd/devices/m25p80.c123456789static int m25p_probe(struct spi_device *spi)&#123; ... nor-&gt;read = m25p80_read; nor-&gt;write = m25p80_write; nor-&gt;write_reg = m25p80_write_reg; nor-&gt;read_reg = m25p80_read_reg; ...&#125;调用spi_nor_scan函数, 获取id, 得到nor flash信息, 然后配置type, writesize, size等参数, 设置_erase, _read, _write回调函数[src]drivers/mtd/devices/m25p80.c1234567891011121314int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)&#123; ... jinfo = spi_nor_read_id(nor); ... mtd-&gt;priv = nor; mtd-&gt;type = MTD_NORFLASH; mtd-&gt;writesize = 1; mtd-&gt;flags = MTD_CAP_NORFLASH; mtd-&gt;size = info-&gt;sector_size * info-&gt;n_sectors; mtd-&gt;_erase = spi_nor_erase; mtd-&gt;_read = spi_nor_read_ext; ...&#125;调用mtd_device_register函数, 解析设备树中的分区表, 添加分区信息[src]drivers/mtd/mtdcore.c1234567891011int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types, struct mtd_part_parser_data *parser_data, const struct mtd_partition *parts, int nr_parts)&#123; ... ret = parse_mtd_partitions(mtd, types, &amp;parsed, parser_data); ... ret = mtd_add_device_partitions(mtd, &amp;parsed); ...&#125;参考文章Linux SPI/QSPI nor flash相关驱动代码","categories":[{"name":"xilinx","slug":"xilinx","permalink":"http://yoursite.com/categories/xilinx/"}],"tags":[{"name":"xilinx","slug":"xilinx","permalink":"http://yoursite.com/tags/xilinx/"},{"name":"qspi","slug":"qspi","permalink":"http://yoursite.com/tags/qspi/"}]}]}