{"meta":{"title":"make.believe","subtitle":null,"description":null,"author":"Klein","url":"http://balost.github.io"},"pages":[{"title":"关于我","date":"2018-08-16T09:51:57.000Z","updated":"2018-08-21T10:40:28.148Z","comments":true,"path":"about/index.html","permalink":"http://balost.github.io/about/index.html","excerpt":"","text":"卧槽, 这扑街真懒, 什么都没写, 得好好安排一下."},{"title":"分类","date":"2018-07-23T03:56:24.000Z","updated":"2018-08-20T08:43:18.314Z","comments":false,"path":"categories/index.html","permalink":"http://balost.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-23T04:23:23.000Z","updated":"2018-08-20T08:43:52.745Z","comments":true,"path":"tags/index.html","permalink":"http://balost.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"NTRIP通信协议之NTRIPCaster","slug":"ntripcaster","date":"2018-09-12T03:57:53.000Z","updated":"2018-09-19T01:43:56.488Z","comments":true,"path":"3453995741/","link":"","permalink":"http://balost.github.io/3453995741/","excerpt":"前言NTRIP(Networked Transport of RTCM via Internet Protocol)是一种基于HTTP协议的数据传输协议, 在互联网上进行RTK(Real Time Kinematic)(实时动态载波相位差分技术)数据(NCT, RTCM, CMR, CMR+等等)传输的协议. NTRIP主要由Client, Caster, Server三个部分组成. 这里搭建一个简单的NTRIPCaster.","text":"前言NTRIP(Networked Transport of RTCM via Internet Protocol)是一种基于HTTP协议的数据传输协议, 在互联网上进行RTK(Real Time Kinematic)(实时动态载波相位差分技术)数据(NCT, RTCM, CMR, CMR+等等)传输的协议. NTRIP主要由Client, Caster, Server三个部分组成. 这里搭建一个简单的NTRIPCaster.NTRIPCaster功能NTRIPCaster主要实现以下几个功能:NTRIPServer连接管理NTRIPServer端请求连接NTRIPCaster时, NTRIPCaster检查是否存在请求的挂载点, 如果挂载点不存在, 将挂载点加入到挂载点链表; NTRIPServer端断开连接时, 将挂载点从挂载点链表移除;NTRIPClient连接管理NtripClient端请求获得差分数据, NTRIPCaster解析NTRIPClient发送的请求数据, 检查挂载点, 检查用户名和密码, 确认无误后, 将NTRIPClient端的socket保存到挂载点节点中, 随后NTRIPServer发送RTK数据后进行转发; NTRIPClient端断开连接时, 将socket从挂载点节点中移除;返回源列表信息NTRIPClient端请求获得源列表时, NTRIPCaster从文件中读取挂载点详细信息, 按照NTRIP协议进行封装, 发送回NTRIPClient端;转发RTK数据NTRIPClient端与NTRIPServer端已经存在连接链表时, NTRIPCaster将转发NTRIPServer端发送的RTK数据到NTRIPClient端;处理GGA数据如果NTRIPCaster作为虚拟基准站, NTRIPClient端要发送自身位置信息(GPGGA数据)到NTRIPCaster, NTRIPCaster使用该坐标以及NTRIPServer发送的RTK数据进行二次处理, 再将得到的RTK数据到NTRIPClient端;NTRIPCaster实现主要流程设计NTRIPCaster使用epoll模型来实现高并发网络编程, 创建一个epoll对象, 然后创建一个TCP服务器(TCP Server), 添加进epoll对象的监听列表, 等待客户端的连接;客户端连接NTRIPCaster时, NTRIPCaster调用accept函数生成一个新的socket, 并将其添加进epoll对象的监听列表;客户端连接向NTRIPCaster发送数据时, NTRIPCaster接受并解析数据, 确认数据是NtripClient或NTRIPServer发过来的及数据的内容, 然后作出相应处理;客户端断开连接时, NTRIPCaster确认是NtripClient或NTRIPServer断开连接, 然后作出相应处理;核心代码主体运行部分:[src]caster.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void ntrip_caster::run(int time_out)&#123; ... for(int i = 0; i &lt; ret; i++)&#123; /* 监听到作为服务器的socket有事件发生. */ if(m_epoll_events[i].data.fd == m_listen_sock)&#123; /* EPOLLIN 事件说明有新的客户端请求连接, 向监听列表中添加该socket. */ if(m_epoll_events[i].events &amp; EPOLLIN)&#123; int new_sock = accept_new_client(); &#125; &#125;else&#123; /* EPOLLIN事件说明客户端已经发送数据, 需要接收数据并进行解析. */ if(m_epoll_events[i].events &amp; EPOLLIN)&#123; int recv_count = recv_data(m_epoll_events[i].data.fd, recv_buf); /* 接受到的数据长度为0, 客户端出错或者连接关闭, 从监听列表中移除该socket. */ if(recv_count == 0)&#123; int sock = m_epoll_events[i].data.fd; /* 如果是NTRIPClient端socket, 从挂载点节点中移除此socket. */ struct mnt_info *mi_ptr = check_conn(sock); if(mi_ptr &amp;&amp; mi_ptr-&gt;current_conn_cursor != -1)&#123; del_conn(mi_ptr); &#125; /* 如果是NTRIPServer端socket, 移除挂载点. */ if(check_mntpoint(sock, NULL) != NULL)&#123; del_mntpoint(sock); &#125; /* 从监听列表中移除该socket. */ if(!epoll_ctl(m_epoll_fd, EPOLL_CTL_DEL, sock, &amp;m_epoll_events[i]))&#123; close(sock); &#125; continue; &#125; if(recv_count &lt; 0) continue; memcpy(send_buf, recv_buf, recv_count); /* 进行数据解析. */ parse_data(m_epoll_events[i].data.fd, recv_buf, recv_count); memset(recv_buf, 0, strlen(recv_buf)); &#125;else if(m_epoll_events[i].events &amp; EPOLLOUT)&#123; int send_count = send_data(m_epoll_events[i].data.fd, send_buf, strlen(send_buf)); memset(send_buf, 0, send_count); &#125; &#125; &#125; ...&#125;数据解析部分:[src]caster.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111int ntrip_caster::parse_data(int sock, char* recv_data, int data_len)&#123; ... /* 逐行解析数据. */ result = strtok(temp, \"\\n\"); if(result != NULL) &#123; /* NTRIPServer请求连接Caster. */ if(!strncasecmp(result, \"POST /\", 6))&#123; /* 截取挂载点名字. */ sscanf(result+6, \"%[^ ]\", m_mnt); /* 检查挂载点是否已经存在. */ struct mnt_info *mi_ptr = check_mntpoint(-1, m_mnt); if(mi_ptr != NULL)&#123; cout &lt;&lt; \"MountPoint already used!!!\" &lt;&lt; endl; /* 向NTRIPServer返回错误信息. */ send_data(sock, \"ERROR - Bad Password\\r\\n\", 22); return -1; &#125; result = strtok(NULL, \"\\n\"); while(result != NULL) &#123; if(!strncasecmp(result, \"Authorization: Basic\", 20))&#123; /* 截取重新编码后挂载点用户名和密码. */ sscanf(result+21, \"%[^\\r]\", m_userpwd); if(strlen(m_userpwd) &gt; 0 )&#123; /* 解码挂载点用户名和密码. */ base64_decode(m_userpwd, m_mntusr, m_password); /* 向挂载点链表添加挂载点. */ add_mntpoint(sock, m_mnt, m_mntusr, m_mntpwd); /* 向NTRIPServer返回正确信息, NTRIPServer收到该信息后开始向NTRIPCaster发送RTK数据. */ send_data(sock, \"ICY 200 OK\\r\\n\", 12); return 0; &#125; &#125; result = strtok(NULL, \"\\n\"); &#125; &#125; /* 检测当前socket是否为已存在的挂载点(NTRIPServer), 若是则说明该数据为RTK数据, 需要转发给连接上此挂载点的NTRIPClient. */ if(struct mnt_info *mi_ptr = check_mntpoint(sock, NULL))&#123; if(mi_ptr != NULL)&#123; for(int i = 0; i &lt; mi_ptr-&gt;current_conn_count; ++i)&#123; if(mi_ptr-&gt;conn_sock[i] &gt; 0) send_data(mi_ptr-&gt;conn_sock[i], recv_data, data_len); &#125; &#125; return 0; &#125; /* NTRIPClient请求获得源列表, 从文件中读取源列表信息, 将数据返回NTRIPClient. */ if(!strncasecmp(result, \"GET / HTTP/1.1\", 14))&#123; char *st_data = new char[MAX_LEN]; get_sourcetable(st_data, MAX_LEN); send_data(sock, st_data, strlen(st_data)); return 0; &#125; /* NTRIPClient请求连接挂载点(NTRIPServer)获取RTK数据. */ if(!strncasecmp(result, \"GET /\", 5) &amp;&amp; NULL != strstr(result, \"HTTP/1.1\"))&#123; /* 截取挂载点名字. */ sscanf(result, \"GET /%s HTTP/1.1\", m_mnt); /* 检查挂载点是否存在. */ struct mnt_info *mi_ptr = check_mntpoint(-1, m_mnt); if(mi_ptr == NULL)&#123; cout &lt;&lt; \"MountPoint not find!!!\" &lt;&lt; endl; /* 向NTRIPClient返回错误信息. */ send_data(sock, \"HTTP/1.1 401 Unauthorized\\r\\n\", 27); return -1; &#125; result = strtok(NULL, \"\\n\"); while(result != NULL) &#123; if(!strncasecmp(result, \"Authorization: Basic\", 20))&#123; /* 截取重新编码后用户名和密码. */ sscanf(result+21, \"%[^\\r]\", m_userpwd); if(strlen(m_userpwd) &gt; 0 )&#123; /* 解码用户名和密码. */ base64_decode(m_userpwd, m_username, m_password); /* 检验用户名和密码是否一致. */ if(!strncpy(mi_ptr-&gt;username, m_username, strlen(m_username)) &amp;&amp; !strncpy(mi_ptr-&gt;password, m_password, strlen(m_password)))&#123; cout &lt;&lt; \"Password error!!!\" &lt;&lt; endl; /* 向NTRIPClient返回错误信息. */ send_data(sock, \"HTTP/1.1 401 Unauthorized\\r\\n\", 27); return -1; &#125; /* 将该socket保存到已找到的挂载点节点中. */ add_conn(mi_ptr, sock); /* 向NTRIPClient返回正确信息. */ send_data(sock, \"ICY 200 OK\\r\\n\", 12); return 0; &#125; &#125; result = strtok(NULL, \"\\n\"); &#125; &#125; /* 如果NTRIPCaster作为虚拟基准站, NTRIPClient需要发送自身坐标(GPGGA)数据, NTRIPCaster以此坐标生成RTK数据, 返回给NTRIPClient. */ if(!strncasecmp(result, \"$GPGGA,\", 7))&#123; if(!check_sum(result))&#123; cout &lt;&lt; \"check pass\" &lt;&lt; endl; /* 数据处理部分未实现, 暂时没有此需求. */ return 0; &#125; &#125; &#125; ...&#125;项目源码: Github参考文章Ntrip通讯协议1.0linux c/c++网络编程之—epoll 模型","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://balost.github.io/categories/C-C/"}],"tags":[{"name":"NTRIPCaster","slug":"NTRIPCaster","permalink":"http://balost.github.io/tags/NTRIPCaster/"},{"name":"Ntrip协议2.0","slug":"Ntrip协议2-0","permalink":"http://balost.github.io/tags/Ntrip协议2-0/"},{"name":"网络编程","slug":"网络编程","permalink":"http://balost.github.io/tags/网络编程/"}]},{"title":"Base64编码与解码","slug":"base64code","date":"2018-09-05T01:51:19.000Z","updated":"2018-09-05T03:13:00.812Z","comments":true,"path":"1443023263/","link":"","permalink":"http://balost.github.io/1443023263/","excerpt":"简介Base64是一种基于64个可打印字符来表示二进制数据的表示方法. 网络信息传递时, 一些二进制资源往往需要转换为Base64编码进行传输, 以提高传输效率. 标准编码表一般为ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/这64个字符. 因为编码后的+/等字符, 标准的Base64并不适合直接放在URL里传输, 有一些Base64的变种, 它们将+/等符号转换为其他符号(如_-), 这样就能安全的在URL中传输了. 虽然编码后字符内容长度会增加大约1/3, 但是在一定程度上保证了一些不可打印字符在传输时的的信息完整性.","text":"简介Base64是一种基于64个可打印字符来表示二进制数据的表示方法. 网络信息传递时, 一些二进制资源往往需要转换为Base64编码进行传输, 以提高传输效率. 标准编码表一般为ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/这64个字符. 因为编码后的+/等字符, 标准的Base64并不适合直接放在URL里传输, 有一些Base64的变种, 它们将+/等符号转换为其他符号(如_-), 这样就能安全的在URL中传输了. 虽然编码后字符内容长度会增加大约1/3, 但是在一定程度上保证了一些不可打印字符在传输时的的信息完整性.转换规则进行Base64转换的时候, 将3个byte(3*8bit=24bit)的数据, 先后放入一个24bit的缓冲区中, 先来的byte占高位. 数据不足3byte的话, 于缓冲器中剩下的bit用0补足. 然后,每次取出6个bit(24/6=4), 因为2^6=64, 按照其值选择编码表中对应的字符作为编码后的输出, 不断进行,直到全部输入数据转换完成. 当原数据长度不是3byte的整数倍时, 如果最后剩下1个输入数据, 在编码结果后加2个“=”; 如果最后剩下2个输入数据, 编码结果后加1个“=”; 如果没有剩下任何数据, 就什么都不要加.C示例源码[src]base64code.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;const char base64code[64] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";/* 根据字符值返回对应编表中的位置. */int chr2index(char ch)&#123; int i; for(i=0; i&lt; strlen(base64code); ++i)&#123; if(ch == base64code[i]) return i; &#125;&#125;/* 根据位置返回对应编表中的字符值. */char index2chr(int index)&#123; return base64code[index];&#125;/* 编码函数. */int encode(char *src, char *result)&#123; char temp[3] = &#123;0&#125;; int i = 0, j = 0, count = 0; int len = strlen(src); if(len==0) return -1; /* 原数据长度不为3的整数倍时, 计算需要补'='个数. */ if(len%3 != 0)&#123; count = 3 - len%3; &#125; while(i&lt;len)&#123; /* 每次处理3个char. */ strncpy(temp, src+i, 3); /* 提取原数据第1个char高6bit, 根据编码表得到对应的编码后字符. */ result[j+0] = index2chr((temp[0]&amp;0xFC)&gt;&gt;2); /* 提取原数据第1个char低2bit和第2个char的高4bit, 根据编码表得到对应的编码后字符. */ result[j+1] = index2chr(((temp[0]&amp;0x3)&lt;&lt;4) | ((temp[1]&amp;0xF0)&gt;&gt;4)); /* 原数据剩余1个char. */ if(temp[1]==0) break; /* 提取第2个char低4bit和第3个char的高2bit, 根据编码表得到对应的编码后字符. */ result[j+2] = index2chr(((temp[1]&amp;0xF)&lt;&lt;2) | ((temp[2]&amp;0xC0)&gt;&gt;6)); /* 原数据剩余2个char. */ if(temp[2]==0) break; /* 提取第3个char低6bit, 根据编码表得到对应字符. */ result[j+3] = index2chr(temp[2]&amp;0x3F); i+=3; j+=4; memset(temp, 0x0, 3); &#125; /* 补'='. */ while(count)&#123; result[j+4-count] = '='; --count; &#125; return 0;&#125;/* 解码函数. */int decode(char *src, char *result)&#123; char temp[4] = &#123;0&#125;; int i = 0, j = 0; int len = strlen(src); if(len==0 || len%4!=0) return 0; while(i&lt;len)&#123; /* 每次处理4个char. */ strncpy(temp, src+i, 4); /* 原数据每个char在编码表中对应的索引值的有效位为低6bit. */ /* 取原数据第1个char 根据编码表得到索引值, 将索引值有效位直接作为新char的高6bit, * 再取原数据第2个char, 根据编码表得到索引值, 将索引值有效位的高2bit作为新char的低2bit. */ result[j+0] = ((chr2index(temp[0])&amp;0x3F) &lt;&lt; 2) | ((chr2index(temp[1])&amp;0x3F) &gt;&gt; 4); /* 原数据出现'=', 说明后面内容无意义. */ if(temp[2] == '=') break; /* 取原数据第2个char, 根据编码表得到索引值, 将索引值有效位的低4bit作为新char的高6bit, * 再取原数据第3个char, 根据编码表得到索引值, 将索引值有效位的前4bit作为新char的低2bit. */ result[j+1] = ((chr2index(temp[1])&amp;0xF) &lt;&lt; 4) | ((chr2index(temp[2])&amp;0x3F) &gt;&gt; 2); /* 原数据出现'=', 说明后面内容无意义. */ if(temp[3] == '=') break; /* 取原数据第3个char, 根据编码表得到索引值, 将索引值有效位的低2bit作为新char的高2bit, * 再取原数据第4个char, 根据编码表得到索引值, 将索引值有效位直接作为新char的低6bit. */ result[j+2] = ((chr2index(temp[2])&amp;0x3) &lt;&lt; 6) | ((chr2index(temp[3])&amp;0x3F)); i+=4; j+=3; memset(temp, 0x0, 4); &#125; return 0;&#125;int main(void)&#123; char userpwd[32] = &#123;\"username:passwd\"&#125;; char result1[64] = &#123;0&#125;; char result2[64] = &#123;0&#125;; printf(\"source data: [%s]\\n\", userpwd); encode(userpwd, result1); printf(\"encode result: [%s]\\n\", result1); decode(result1, result2); printf(\"decode result: [%s]\\n\", result2); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://balost.github.io/categories/算法/"}],"tags":[{"name":"Base64","slug":"Base64","permalink":"http://balost.github.io/tags/Base64/"},{"name":"算法","slug":"算法","permalink":"http://balost.github.io/tags/算法/"}]},{"title":"Arm Linux下使用ldd","slug":"arm-ldd","date":"2018-08-21T04:16:24.000Z","updated":"2018-08-21T04:45:47.069Z","comments":true,"path":"3476998492/","link":"","permalink":"http://balost.github.io/3476998492/","excerpt":"前言ldd命令用于打印程序或者库文件所依赖的共享库列表, ldd不是一个可执行程序, 而只是一个shell脚本. ldd显示可执行模块的依赖的工作原理, 其实质是通过ld-linux.so(动态库链接器)来实现的. ldd能够显示可执行模块的依赖, 其原理是通过设置一些的环境变量, 如LD_TRACE_LOADED_OBJECTS, LD_WARN, LD_BIND_NOW, LD_LIBRARY_VERSION, LD_VERBOSE等. 当LD_TRACE_LOADED_OBJECTS环境变量不为空时, 任何可执行程序在运行时, 它都会只显示模块的依赖, 而程序并不真正执行. 实际上可以直接执行ld-linux.so模块, 如: /lib/ld-linux.so.2 --list ls(这条命令相当于ldd ls).","text":"前言ldd命令用于打印程序或者库文件所依赖的共享库列表, ldd不是一个可执行程序, 而只是一个shell脚本. ldd显示可执行模块的依赖的工作原理, 其实质是通过ld-linux.so(动态库链接器)来实现的. ldd能够显示可执行模块的依赖, 其原理是通过设置一些的环境变量, 如LD_TRACE_LOADED_OBJECTS, LD_WARN, LD_BIND_NOW, LD_LIBRARY_VERSION, LD_VERBOSE等. 当LD_TRACE_LOADED_OBJECTS环境变量不为空时, 任何可执行程序在运行时, 它都会只显示模块的依赖, 而程序并不真正执行. 实际上可以直接执行ld-linux.so模块, 如: /lib/ld-linux.so.2 --list ls(这条命令相当于ldd ls).ubuntu下的lddubuntu下的ldd位于/usr/bin/ldd, 文件内容如下:[src]/usr/bin/ldd123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#! /bin/bash# Copyright (C) 1996-2016 Free Software Foundation, Inc.# This file is part of the GNU C Library.# The GNU C Library is free software; you can redistribute it and/or# modify it under the terms of the GNU Lesser General Public# License as published by the Free Software Foundation; either# version 2.1 of the License, or (at your option) any later version.# The GNU C Library is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU# Lesser General Public License for more details.# You should have received a copy of the GNU Lesser General Public# License along with the GNU C Library; if not, see# &lt;http://www.gnu.org/licenses/&gt;.# This is the `ldd' command, which lists what shared libraries are# used by given dynamically-linked executables. It works by invoking the# run-time dynamic linker as a command and setting the environment# variable LD_TRACE_LOADED_OBJECTS to a non-empty value.# We should be able to find the translation right at the beginning.TEXTDOMAIN=libcTEXTDOMAINDIR=/usr/share/localeRTLDLIST=\"/lib/ld-linux.so.2 /lib64/ld-linux-x86-64.so.2 /libx32/ld-linux-x32.so.2\"warn=bind_now=verbose=while test $# -gt 0; do case \"$1\" in --vers | --versi | --versio | --version) echo 'ldd (Ubuntu GLIBC 2.23-0ubuntu10) 2.23' printf $\"Copyright (C) %s Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\" \"2016\" printf $\"Written by %s and %s.\" \"Roland McGrath\" \"Ulrich Drepper\" exit 0 ;; --h | --he | --hel | --help) echo $\"Usage: ldd [OPTION]... FILE... --help print this help and exit --version print version information and exit -d, --data-relocs process data relocations -r, --function-relocs process data and function relocations -u, --unused print unused direct dependencies -v, --verbose print all information\" printf $\"For bug reporting instructions, please see:\\\\n%s.\\\\n\" \\ \"&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;\" exit 0 ;; -d | --d | --da | --dat | --data | --data- | --data-r | --data-re | \\ --data-rel | --data-relo | --data-reloc | --data-relocs) warn=yes shift ;; -r | --f | --fu | --fun | --func | --funct | --functi | --functio | \\ --function | --function- | --function-r | --function-re | --function-rel | \\ --function-relo | --function-reloc | --function-relocs) warn=yes bind_now=yes shift ;; -v | --verb | --verbo | --verbos | --verbose) verbose=yes shift ;; -u | --u | --un | --unu | --unus | --unuse | --unused) unused=yes shift ;; --v | --ve | --ver) echo &gt;&amp;2 $\"ldd: option \\`$1' is ambiguous\" exit 1 ;; --) # Stop option processing. shift; break ;; -*) echo &gt;&amp;2 'ldd:' $\"unrecognized option\" \"\\`$1'\" echo &gt;&amp;2 $\"Try \\`ldd --help' for more information.\" exit 1 ;; *) break ;; esacdonenonelf ()&#123; # Maybe extra code for non-ELF binaries. return 1;&#125;add_env=\"LD_TRACE_LOADED_OBJECTS=1 LD_WARN=$warn LD_BIND_NOW=$bind_now\"add_env=\"$add_env LD_LIBRARY_VERSION=\\$verify_out\"add_env=\"$add_env LD_VERBOSE=$verbose\"if test \"$unused\" = yes; then add_env=\"$add_env LD_DEBUG=\\\"$LD_DEBUG$&#123;LD_DEBUG:+,&#125;unused\\\"\"fi# The following command substitution is needed to make ldd work in SELinux# environments where the RTLD might not have permission to write to the# terminal. The extra \"x\" character prevents the shell from trimming trailing# newlines from command substitution results. This function is defined as a# subshell compound list (using \"(...)\") to prevent parameter assignments from# affecting the calling shell execution environment.try_trace() ( output=$(eval $add_env '\"$@\"' 2&gt;&amp;1; rc=$?; printf 'x'; exit $rc) rc=$? printf '%s' \"$&#123;output%x&#125;\" return $rc)case $# in0) echo &gt;&amp;2 'ldd:' $\"missing file arguments\" echo &gt;&amp;2 $\"Try \\`ldd --help' for more information.\" exit 1 ;;1) single_file=t ;;*) single_file=f ;;esacresult=0for file do # We don't list the file name when there is only one. test $single_file = t || echo \"$&#123;file&#125;:\" case $file in */*) : ;; *) file=./$file ;; esac if test ! -e \"$file\"; then echo \"ldd: $&#123;file&#125;:\" $\"No such file or directory\" &gt;&amp;2 result=1 elif test ! -f \"$file\"; then echo \"ldd: $&#123;file&#125;:\" $\"not regular file\" &gt;&amp;2 result=1 elif test -r \"$file\"; then RTLD= ret=1 for rtld in $&#123;RTLDLIST&#125;; do if test -x $rtld; then dummy=`$rtld 2&gt;&amp;1` if test $? = 127; then verify_out=`$&#123;rtld&#125; --verify \"$file\"` ret=$? case $ret in [02]) RTLD=$&#123;rtld&#125;; break;; esac fi fi done case $ret in 0|2) try_trace \"$RTLD\" \"$file\" || result=1 ;; 1) # This can be a non-ELF binary or no binary at all. nonelf \"$file\" || &#123; echo $\" not a dynamic executable\" result=1 &#125; ;; *) echo 'ldd:' $&#123;RTLD&#125; $\"exited with unknown exit code\" \"($ret)\" &gt;&amp;2 exit 1 ;; esac else echo 'ldd:' $\"error: you do not have read permission for\" \"\\`$file'\" &gt;&amp;2 result=1 fidoneexit $result# Local Variables:# mode:ksh# End:在arm平台上使用因为ldd是一个脚本, 所以只需稍作修改就可以在arm平台执行. 首先替换脚本解释器, arm平台用的基本都是/bin/sh:[src]/bin/ldd12- #! /bin/bash+ #! /bin/sh然后替换动态库链接器, 我的交叉编译工具使用的是ld-linux-hf.so.3, 因此修改如下:[src]/bin/ldd12- RTLDLIST=\"/lib/ld-linux.so.2 /lib64/ld-linux-x86-64.so.2 /libx32/ld-linux-x32.so.2\"+ RTLDLIST=\"/lib/ld-linux-hf.so.3\"将修改好的ldd文件拷贝到开发板上/bin目录下, 测试:123456$ ldd --version ldd (GNU libc) 2.26Copyright (C) 2017 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.Written by Roland McGrath and Ulrich Drepper.测试通过.测试环境@系统: Windows 7 Professional with SP1@Vivado: 2015.04@虚拟机: OSRC_Miz7_ubuntu_14@开发板: 米联MIZ702N参考文章ldd命令","categories":[{"name":"Linux","slug":"Linux","permalink":"http://balost.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://balost.github.io/tags/Linux/"},{"name":"嵌入式","slug":"嵌入式","permalink":"http://balost.github.io/tags/嵌入式/"}]},{"title":"Linux下配置软AP分享Wifi热点","slug":"softap","date":"2018-08-20T04:39:51.000Z","updated":"2018-08-20T09:54:26.954Z","comments":true,"path":"1178631641/","link":"","permalink":"http://balost.github.io/1178631641/","excerpt":"前言最近有个项目要求用无线网卡开启wifi热点, 由于板子目前还没回来, 那么先在Ubuntu下测试, 后面在进行移植. 我之前使用过Ubuntu自带的网络管理器和kde-nm-connection-editor(为了改mode从而使Android设备能识别, 后来发现其实可以直接改配置文件)成功搭建过wifi热点, 现在在ububtu14.04上试了很多次未成功(无法连接到隐藏网络), 后来一想最后要移植到开发板上, 应该是不用图形界面的, 还是老老实实用命令行配置吧. 使用命令行配置的话, 要用Hostapd创建一个无线接入点, 然后配置连接终端可以自动获取ip地址, 再共享以太网给无线网卡, 此时应该就可以正常上网了, 那么就开始吧.","text":"前言最近有个项目要求用无线网卡开启wifi热点, 由于板子目前还没回来, 那么先在Ubuntu下测试, 后面在进行移植. 我之前使用过Ubuntu自带的网络管理器和kde-nm-connection-editor(为了改mode从而使Android设备能识别, 后来发现其实可以直接改配置文件)成功搭建过wifi热点, 现在在ububtu14.04上试了很多次未成功(无法连接到隐藏网络), 后来一想最后要移植到开发板上, 应该是不用图形界面的, 还是老老实实用命令行配置吧. 使用命令行配置的话, 要用Hostapd创建一个无线接入点, 然后配置连接终端可以自动获取ip地址, 再共享以太网给无线网卡, 此时应该就可以正常上网了, 那么就开始吧.确认网卡是否支持master模式在命令行终端输入iw list命令:12345678$ sudo iw list... Supported interface modes: * IBSS * managed * AP * AP/VLAN...如果Supported interface modes中有AP或AP/VLAN, 说明这张网卡支持master模式, 接着往下看.配置hostapd编写/etc/hostapd/hostapd.conf文件, 输入以下内容:[src]/etc/hostapd/hostapd.conf12345678910111213interface=wlan0#bridge=br0driver=nl80211ssid=softapchannel=1hw_mode=gignore_broadcast_ssid=0auth_algs=1wpa=3wpa_passphrase=11111111wpa_key_mgmt=WPA-PSKwpa_pairwise=TKIPrsn_pairwise=CCMP接下来看看这些配置部分选项说明:12345678910interface: Atheros 接口始终名为 athx, 所有其他接口都是wlanx.bridge: 如果接入点没有以太网桥接, 可以省略bridge一行的内容.driver: 如果使用的是hostapd V0.6.8或其更高版本以及具有mac80211支持的WI, 那么驱动程序是nl80211. 惟一受支持的旧版驱动程序是HostAP,madwifi和prism54. V0.6.8之前的hostapd发行版支持hostap,wiredk,madwifi,test,nl80211和bsd驱动程序.ssid: 接入点名称.channel: 802.11b/g都最多只有三条互不干扰的信道, 即1,6,11, 选择其中一个就行.auth_algs：1表示只支持WPA2身份验证算法; 2表示只支持WEP; 3表示支持这两种方式. 永远不要使用有线等效加密(wired equivalent privacy, WEP), 因为它非常容易破解, 并且多年前就已经被完全破解了.wpa: 1表示支持WPA1; 2仅支持WPA2; 3表示二者都支持.wpa_passphrase: 接入点密码;wpa_key_mgmt: 支持的加密密钥算法. 选择有WPA-PSK,WPA-EAP或两者均使用. PSK是预共享密钥. EAP是可扩展认证协议, 是一个支持许多不同身份验证方法的框架, 对于小的预共享密钥设置, 不需要使用它.wpa_pairwise,rsn_pairwise: 控制支持加密数据的密钥, 您可以使用CCMP,TKIP或两者均使用. CCMP比TKIP更强, 因此建议仅支持CCMP.编写完成后, 在终端输入以下内容, 测试配置文件是否有问题:1$ hostadp /etc/hostapd/hostapd.conf这时, 你的手机可以搜索到该热点, 但由于无法获取到IP地址仍然无法连接.连接网络可以选择NAT或是网桥方式来使该AP的接入设备获得ip地址.NAT选择NAT方式的话, 要先为接入设备分配ip地址, 就能够连上热点, 但是无法连到网络. 通过配置NAT, 让终端发出的数据包的IP修改为公网IP, 即可连上网络. 首先为无线网卡分配IP地址并启用：1$ sudo ifconfig wlan0 192.168.3.1 netmask 255.255.255.0 up这里介绍两种自动获取IP服务配置:DHCP安装dnamasq:1$ sudo apt-get install isc-dhcp-server打开/etc/dhcp/dhcpd.conf配置文件, 修改以下内容:[src]/etc/dhcp/dhcpd.conf12345subnet 192.168.3.0 netmask 255.255.255.0 &#123; range 192.168.3.20 192.168.3.200; option routers 192.168.3.1; option domain-name-servers 8.8.8.8;&#125;重启dnamasq服务:1$ sudo service isc-dhcp-server restartDNSMASQ在命令行终端输入输入以下命令安装dnamasq:1$ sudo apt-get install dnsmasq打开/etc/dnsmasq.conf配置文件, 添加以下内容:[src]/etc/dnsmasq.conf12345interface=wlan0listen-address=192.168.3.1#no-dhcp-interface=dhcp-range=192.168.3.20,192.168.3.200,12hserver=/google/8.8.8.8重启dnamasq服务:1$ sudo service dnsmasq restart出现OK就成功了.配置NAT通过上面两种配置后, 手机可以连接上热点, 但还无法连接外网, 需要配置路由转发. 首先打开内核的ip转发功能:1$ sudo echo \"1\" &gt; /proc/sys/net/ipv4/ip_forward使用iptables设置转发:123$ sudo iptables -t nat -I POSTROUTING -o eth0 -j MASQUERADE $ sudo iptables -A FORWARD -s 192.168.3.0/24 -j ACCEPT$ sudo iptables -A FORWARD -d 192.168.3.0/24 -j ACCEPT不出意外, 此时手机应该可以连接上外网了.网桥选择的是网桥方式, 那么IP地址将会由电脑实际连接的外网分配, 并且连接的终端可以直接发送数据到外网. 热点连上了就可以直接用了, 且和计算机的有线端同处于一个子网. 首先创建一个虚拟的以太网桥接口:1$ sudo brctl addbr br0我们不需要STP(生成树协议)等. 因为我们只有一个路由器，是绝对不可能形成一个环的, 我们可以关闭这个功能.1$ sudo brctl stp br0 off添加以太网物理接口和无线网卡接口到网桥上:12$ sudo brctl addif br0 eth0$ sudo brctl addif br0 wlan0如果wlan0无法添加, 尝试以下命令:1$ sudo iw dev wlan0 set 4addr on配置网桥的IP和默认网关, 要和机器所在局域网同一网段:12$ sudo ifconfig br0 192.168.2.184 netmask 255.255.255.0 up$ sudo route add default gw 192.168.2.1以太网物理接口和无线网卡接口成为网桥设备的一部分了, 所以不再需要IP地址.下面我们将这些IP地址释放掉:1234$ sudo ifconfig eth0 down$ sudo ifconfig wlan0 down$ sudo ifconfig eth0 0.0.0.0 up$ sudo ifconfig wlan0 0.0.0.0 up启用网桥设备:1$ sudo ifconfig br0 up大功告成, 尽情享受吧!参考文章linux软AP－－hostapd+dhcpd使用 hostapd 轻松实现强 WiFi 加密","categories":[{"name":"Linux","slug":"Linux","permalink":"http://balost.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://balost.github.io/tags/Linux/"},{"name":"网络","slug":"网络","permalink":"http://balost.github.io/tags/网络/"}]},{"title":"嵌入式LINUX下CGI与HTML网页之间的通信","slug":"cgi-html","date":"2018-08-15T07:04:34.000Z","updated":"2018-08-16T09:18:50.377Z","comments":true,"path":"1522571396/","link":"","permalink":"http://balost.github.io/1522571396/","excerpt":"前言CGI 是Web服务器运行时外部程序的规范, 按CGI编写的程序可以扩展服务器功能. CGI应用程序能与浏览器进行交互, 还可通过数据库API与数据库服务器等外部数据源进行通信, 从数据库服务器中获取数据.几乎所有服务器都支持CGI,可用任何语言编写CGI,包括C/C++, Python, Shell等.本文通过编写一个简单的登录的用例来了解CGI与HTML如何互相传递参数. 要在CGI和HTML之间传递数据, 需要移植CGI库, 由于比较简单这里就不再赘述, 本文默认已经移植好了CGI库以及能在开发板上使用httpd服务搭建Web服务器.HTML调用CGI并传递参数在HTML中我们使用表单(from), 采集和提交用户输入信息, 然后调用CGI程序处理:","text":"前言CGI 是Web服务器运行时外部程序的规范, 按CGI编写的程序可以扩展服务器功能. CGI应用程序能与浏览器进行交互, 还可通过数据库API与数据库服务器等外部数据源进行通信, 从数据库服务器中获取数据.几乎所有服务器都支持CGI,可用任何语言编写CGI,包括C/C++, Python, Shell等.本文通过编写一个简单的登录的用例来了解CGI与HTML如何互相传递参数. 要在CGI和HTML之间传递数据, 需要移植CGI库, 由于比较简单这里就不再赘述, 本文默认已经移植好了CGI库以及能在开发板上使用httpd服务搭建Web服务器.HTML调用CGI并传递参数在HTML中我们使用表单(from), 采集和提交用户输入信息, 然后调用CGI程序处理:[src]www/index.html1234567...&lt;form action=\"/cgi-bin/getresult_cgi.cgi\" method=\"POST\"&gt; &lt;input type=\"text\" name=\"Username\" placeholder=\"User\" required=\"required\" /&gt; &lt;input type=\"password\" name=\"Password\" placeholder=\"Passwd\" required=\"required\" /&gt; &lt;button type=\"submit\"&gt; Login &lt;/button&gt;&lt;/form&gt;...Tipsaction为处理表单请求的程序;method表示发送表单信息的方式. method有两个值: GET和POST. GET是把参数数据队列加到提交表单的ACTION属性所指的URL中, 值和表单内各个字段一一对应, 在URL中可以看到; POST是通过HTTP POST机制, 将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址, 用户看不到这个过程. GET一般用于取得和显示数据; POST多用于数据的保存更新;我们来看看CGI程序中是如何接受传递的参数. 首先是获取请求方式, 根据请求方式去拿数据:[src]getresult_cgi.c1234567int main(void)&#123; ... req_method = getenv(\"REQUEST_METHOD\"); input = getcgidata(stdin, req_method); ...&#125;来看下解析数据关键代码:[src]getresult_cgi.c1234567891011121314151617char* getcgidata(FILE* fp, char* requestmethod)&#123; ... if (!strcmp(requestmethod, \"GET\")) &#123; input = getenv(\"QUERY_STRING\"); ... &#125; else if (!strcmp(requestmethod, \"POST\")) &#123; len = atoi(getenv(\"CONTENT_LENGTH\")); input = (char*)malloc(sizeof(char)*(size + 1)); ... while(1) &#123; input[i] = (char)fgetc(fp); ... &#125; &#125; ...&#125;可以看出GET请求传递的参数保存在环境变量QUERY_STRING中, 而POST请求将传递的参数保存在标准输入(stdin)中; 然后开始解析字符串:src:getresult_cgi.c123456int main(void)&#123; ... sscanf(input, \"%*[^=]=%[^&amp;]%*[^=]=%[^EOF]\", name, pass); ...&#125;这里使用sscanf来提取用户名和密码, 从HTML传递过来的参数格式应为:1Username=admin&amp;Password=aaaaasscanf中格式化字符串的含义为:12%*[^=]=%[^&amp;]: 读取‘=’和‘&amp;’之间的字符, 放到name中;%*[^=]=%[^EOF]: 读取‘=’到文件流结尾之前的字符, 放到pass中;至此, 已经将HTML传递过来的参数解析完毕;CGI返回数据给HTML本文要做的是根据用户名和密码正不正确来返回不同信息: 正确返回login success信息, 错误返回输入的用户名和密码. 要将CGI数据传给HTML, 可以在CGI程序中直接生成一个页面, 不过这样好像不够灵活, 那么就使用HTML页面跳转时用来传递数据的Cookie来实现CGI与HTML间数据的传递:[src]getresult_cgi.c12345678910111213int main(void) ... if (!strncmp(name, \"root\", 4) &amp;&amp; !strncmp(pass, \"000\", 3))&#123; printf(\"Set-Cookie: %s=%s; path=/\\r\\n\",\"Result\",\"login success\"); printf(\"%s%c%c\\n\",\"Content-Type:text/html;charset=utf-8\",13,10); printf(\"&lt;meta http-equiv=\\\"refresh\\\" content=\\\"0;url=../result.html\\\"&gt;\"); &#125; else &#123; printf(\"Set-Cookie: %s=%s&amp;&amp;%s; path=/\\r\\n\",\"Result\", name, pass); printf(\"%s%c%c\\n\",\"Content-Type:text/html;charset=utf-8\",13,10); printf(\"&lt;meta http-equiv=\\\"refresh\\\" content=\\\"0;url=../result.html\\\"&gt;\"); &#125; ...&#125;这里要注意的是要先设置Cookie后再输出http请求头, 否则Cookie无效. 接着我们看看HTML是怎么接受Cookie的:[src]www/result.html12345678910...&lt;form&gt; Login Result= &lt;input name=\"lignt_now\" type=\"text\" id=\"result_text\" /&gt;&lt;/form&gt;&lt;script type=\"text/javascript\" &gt; cookie_text= document.getElementById('result_text'); cookie_text.value =getCookie('Result')&lt;/script&gt;...这里使用了一个表单, 表单内有一个文本框, 内容由javascript来填充; 我们再来看看getCookie()做了什么:[src]www/result.html12345678910111213141516171819...&lt;script type=\"text/javascript\" &gt;function getCookie(c_name)&#123; if (document.cookie.length&gt;0) &#123; c_start=document.cookie.indexOf(c_name + \"=\") if (c_start!=-1) &#123; c_start=c_start + c_name.length+1 c_end=document.cookie.indexOf(\";\",c_start) if (c_end==-1) c_end=document.cookie.length return unescape(document.cookie.substring(c_start,c_end)) &#125; &#125; return \"\"&#125;&lt;/script&gt;...前面我们传递的Cookie为“Result=login success”或“Result=username, password”. 在javascript中根据首尾字符使用document.cookie.indexOf()来获取Cookie有效内容的开始和结束位置, 然后根据字符开始和结束位置使用document.cookie.substring()读取子字符串, 最终得到需要的数据.详细代码这里把所有代码都贴出来,首先是CGI程序:[src]getresult_cgi.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;string.h&gt;#include &lt;iconv.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include \"cgi.h\"#include \"aux.h\"char* getcgidata(FILE* fp, char* requestmethod)&#123; char* input; int len; int size = 1024; int i = 0; if (!strcmp(requestmethod, \"GET\")) &#123; input = getenv(\"QUERY_STRING\"); return input; &#125; else if (!strcmp(requestmethod, \"POST\")) &#123; len = atoi(getenv(\"CONTENT_LENGTH\")); input = (char*)malloc(sizeof(char)*(size + 1)); if (len == 0) &#123; input[0] = '\\0'; return input; &#125; while(1) &#123; input[i] = (char)fgetc(fp); if (i == size) &#123; input[i+1] = '\\0'; return input; &#125; --len; if (feof(fp) || (!(len))) &#123; i++; input[i] = '\\0'; return input; &#125; ++i; &#125; &#125; return NULL;&#125;int main(void)&#123; char *input; char *req_method; char name[32]; char pass[32]; req_method = getenv(\"REQUEST_METHOD\"); input = getcgidata(stdin, req_method); /* Format: Username=admin&amp;Password=aaaaa. */ //sscanf(input, \"%*[^=]=%*c%[^&amp;]%*[^=]%*c%[^\\n]\", name, pass); sscanf(input, \"%*[^=]=%[^&amp;]%*[^=]=%[^EOF]\", name, pass); if (!strncmp(name,\"root\",4) &amp;&amp; !strncmp(pass, \"000\", 3))&#123; /* Set Cookie. */ printf(\"Set-Cookie: %s=%s; path=/\\r\\n\",\"Result\",\"login success\"); printf(\"%s%c%c\\n\",\"Content-Type:text/html;charset=utf-8\",13,10); printf(\"&lt;meta http-equiv=\\\"refresh\\\" content=\\\"0;url=../result.html\\\"&gt;\"); &#125; else &#123; printf(\"Set-Cookie: %s=%s&amp;&amp;%s; path=/\\r\\n\",\"Result\", name, pass); printf(\"%s%c%c\\n\",\"Content-Type:text/html;charset=utf-8\",13,10); printf(\"&lt;meta http-equiv=\\\"refresh\\\" content=\\\"0;url=../result.html\\\"&gt;\"); &#125; return 0;&#125;主页index.html:[src]www/index.html12345678910111213&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt; Login &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/cgi-bin/getresult_cgi.cgi\" method=\"POST\"&gt; &lt;input type=\"text\" name=\"Username\" placeholder=\"User\" required=\"required\" /&gt; &lt;input type=\"password\" name=\"Password\" placeholder=\"Passwd\" required=\"required\" /&gt; &lt;button type=\"submit\"&gt; Login &lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;返回结果result.html:[src]www/result.html123456789101112131415161718192021222324252627282930313233&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;script type=\"text/javascript\" &gt;function getCookie(c_name)&#123; if (document.cookie.length&gt;0) &#123; c_start=document.cookie.indexOf(c_name + \"=\") if (c_start!=-1) &#123; c_start=c_start + c_name.length+1 c_end=document.cookie.indexOf(\";\",c_start) if (c_end==-1) c_end=document.cookie.length return unescape(document.cookie.substring(c_start,c_end)) &#125; &#125; return \"\"&#125;&lt;/script&gt;&lt;title&gt;Result&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; Login Result= &lt;input name=\"lignt_now\" type=\"text\" id=\"result_text\" /&gt;&lt;/form&gt;&lt;script type=\"text/javascript\" &gt; bang_text= document.getElementById('result_text'); bang_text.value =getCookie('Result')&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;参考文章嵌入式CGI 与HTML的数据交换CGI编程","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://balost.github.io/categories/嵌入式/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://balost.github.io/tags/嵌入式/"},{"name":"cgi","slug":"cgi","permalink":"http://balost.github.io/tags/cgi/"},{"name":"html","slug":"html","permalink":"http://balost.github.io/tags/html/"}]},{"title":"ZYNQ从BUSYBOX开始制作RAMDISK","slug":"zynq-ramdisk","date":"2018-08-13T10:14:25.000Z","updated":"2018-09-18T08:54:26.752Z","comments":true,"path":"2391800641/","link":"","permalink":"http://balost.github.io/2391800641/","excerpt":"Busybox移植BusyBox将许多具有共性的小版本的UNIX工具结合到一个单一的可执行文件. 这样的集合可以替代大部分常用工具, BusyBox提供了一个比较完善的环境，可以适用于任何小的嵌入式系统.这篇文章将从移植Busybox开始, 一步一步制作一个属于自己的根文件系统.","text":"Busybox移植BusyBox将许多具有共性的小版本的UNIX工具结合到一个单一的可执行文件. 这样的集合可以替代大部分常用工具, BusyBox提供了一个比较完善的环境，可以适用于任何小的嵌入式系统.这篇文章将从移植Busybox开始, 一步一步制作一个属于自己的根文件系统.下载Busybox的官方源码下载路径为: 点我本次下载的是busybox-1.29.1.tar.bz2配置解压下载的文件, 进入到源码根目录:1$ tar xvf busybox-1.29.1.tar.bz2 &amp;&amp; cd busybox-1.29.1先使用默认配置:1$ make deconfig然后输入命令进行配置:1$ make menuconfig配置以下选项:1234Settings ---&gt; [ ] Don't use /usr [ ] Build static binary (no shared libs) (arm-linux-gnueabihf-) Cross compiler prefix第一个是选择是否编译出/usr相关目录, 这里不勾选则生成/usr目录;第二个是选择静态编译不依赖动态库, 制作根文件系统后面会拷贝一套动态连接库, 先不勾选;第三个是配置交叉编译工具, 根据实际情况填写;其他的需要的命令支持自行选择配置.Tips静态编译与动态编译的区别动态编译的可执行文件需要附带一个的动态链接库, 在执行时, 需要调用其对应动态链接库中的命令. 所以其优点一方面是缩小了执行文件本身的体积, 另一方面是加快了编译速度, 节省了系统资源. 缺点一是哪怕是很简单的程序, 只用到了链接库中的一两条命令, 也需要附带一个相对庞大的链接库; 二是如果其他计算机上没有安装对应的运行库, 则用动态编译的可执行文件就不能运行.静态编译就是编译器在编译可执行文件的时候, 将可执行文件需要调用的对应动态链接库(.so)中的部分提取出来, 链接到可执行文件中去, 使可执行文件在运行的时候不依赖于动态链接库. 所以其优缺点与动态编译的可执行文件正好互补.编译1$ make &amp;&amp; make install生成文件位于_install文件夹内:12$ ls _install/bin linuxrc sbin usr拷贝lib库新建一个root目录, 进入该目录下:1$ mkdir root &amp;&amp; cd root/将编译busybox生成的目录下的所有文件拷贝过去:1$ cp -af ../busybox-1.29.1/_install/* .创建其他的目录1$ mkdir dev etc lib sys proc tmp var home root mnt拷贝lib库整个lib库有很多, 全部拷贝的话就有点臃肿了, 下面是我参考官方的ramdisk里面的lib库拷贝的, 应该还可以再精简, 先凑合着用吧:1234567891011121314$ ls lib/ld-2.25.so libcidn-2.25.so libgfortran.so.4 libnss_compat-2.25.so libnss_nis.so.2 libstdc++.so.6ld-linux-armhf.so.3 libcidn.so.1 libgfortran.so.4.0.0 libnss_compat.so.2 libpcprofile.so libstdc++.so.6.0.24libanl-2.25.so libcilkrts.so libgomp.so libnss_db-2.25.so libpthread-2.25.so libstdc++.so.6.0.24-gdb.pylibanl.so.1 libcilkrts.so.5 libgomp.so.1 libnss_db.so.2 libpthread.so.0 libthread_db-1.0.solibasan.so libcilkrts.so.5.0.0 libgomp.so.1.0.0 libnss_dns-2.25.so libresolv-2.25.so libthread_db.so.1libasan.so.4 libcrypt-2.25.so libitm.so libnss_dns.so.2 libresolv.so.2 libubsan.solibasan.so.4.0.0 libcrypt.so.1 libitm.so.1 libnss_files-2.25.so librt-2.25.so libubsan.so.0libatomic.so libc.so.6 libitm.so.1.0.0 libnss_files.so.2 librt.so.1 libubsan.so.0.0.0libatomic.so.1 libdl-2.25.so libm-2.25.so libnss_hesiod-2.25.so libSegFault.so libutil-2.25.solibatomic.so.1.2.0 libdl.so.2 libmemusage.so libnss_hesiod.so.2 libssp.so libutil.so.1libBrokenLocale-2.25.so libgcc_s.so libm.so.6 libnss_nis-2.25.so libssp.so.0libBrokenLocale.so.1 libgcc_s.so.1 libnsl-2.25.so libnss_nisplus-2.25.so libssp.so.0.0.0libc-2.25.so libgfortran.so libnsl.so.1 libnss_nisplus.so.2 libstdc++.so接下来拷贝上面的运行库:1$ cp -af /opt/toolchain/arm-linux-gnueabihf/arm-linux-gnueabihf/libc/lib/*.so* lib/Tips各个交叉编译工具的运行库的所在位置可能不同;部分库文件是符号链接, 要保留原文件属性的前提下复制文件请使用 cp -a 命令;然后去掉库文件的符号表和调试信息进行瘦身, 进一步减少空间占用:1$ arm-linux-gnueabihf-strip lib/*现在整个可执行命令以及运行库已移植完成, 接下来是启动添加配置文件.启动配置文件profile文件新建etc/profile文件, 并添加以下内容:[src]etc/profile123456789#!/bin/shexport HOSTNAME=skycasterexport USER=rootexport HOME=homeexport PS1=\"[$USER@$HOSTNAME \\W]\\# \"PATH=/bin:/sbin:/usr/bin:/usr/sbinLD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATHexport PATH LD_LIBRARY_PATHinittab文件新建etc/inittab文件, 并添加以下内容:[src]etc/inittab123456789#this is run first except when booting in single-user mode. ::sysinit:/etc/init.d/rcS# /bin/sh invocations on selected ttys# start an &quot;askfirst&quot; shell on the console (whatever that may be)::askfirst:-/bin/sh# stuff to do when restarting the init process::restart:/sbin/init# stuff to do before rebooting::ctrlaltdel:/sbin/rebootfstab文件新建etc/fstab文件, 并添加以下内容:[src]etc/fstab12345LABEL=/ / tmpfs defaults 0 0none /dev/pts devpts gid=5,mode=620 0 0none /proc proc defaults 0 0none /sys sysfs defaults 0 0none /tmp tmpfs defaults 0 0rcS文件新建etc/init.d/rcS文件, 并添加以下内容:[src]etc/init.d/rcS12345678910111213141516171819#!/bin/shecho \"Starting rcS...\"echo \"++ Mounting filesystem\"mount -t proc none /procmount -t sysfs none /sysmount -t tmpfs none /tmpecho \"++ Setting up mdev\"echo /sbin/mdev &gt; /proc/sys/kernel/hotplugmdev -smkdir -p /dev/ptsmkdir -p /dev/i2cmount -t devpts devpts /dev/ptsecho \"rcS Complete\"为其添加执行权限和所属用户组:12$ chmod 755 etc/init.d/rcS$ sudo chown root:root etc/init.d/rcSpasswd文件新建etc/passwd文件, 并添加以下内容:[src]etc/passwd1root:$1$qC.CEbjC$SVJyqm.IG.gkElhaeM.FD0:0:0:root:/root:/bin/sh现在根文件系统已经制作完成, 接下来就要制作成ramdisk image.制作ramdisk制作新的ramdisk.image文件系统格式为ext2, 大小为16M:1234$ dd if=/dev/zero of=ramdisk.image bs=1024 count=16384$ mke2fs -F ramdisk.image -L \"ramdisk\" -b 1024 -m 0$ tune2fs ramdisk.image -i 0$ chmod 777 ramdisk.image挂载ramdisk新建一个rootfs目录, 并将ramdisk.image挂载到rootfs目录:123$ mkdir rootfs$ chmod u+rwx ramdisk.image$ sudo mount -o loop ramdisk.image rootfs将制作好的根文件系统全部拷贝到rootfs目录下:1$ cp -af root/* rootfs/*打包ramdisk卸载rootfs, 并打包ramdisk.image:123$ sudo umount rootfs$ gzip ramdisk.image$ mkimage -A arm -T ramdisk -C gzip -d ramdisk.image.gz uramdisk.image.gz使用将ramdisk.image.gz拷贝到/mnt/workspace/linux/output目录下, 执行:1$ mk_kernel.sh &amp;&amp; mk_sdimage.sh将/mnt/workspace/linux/images/sd_image目录下的生成文件拷贝到SD卡, 重新上电, 启动后如下:123456[root@skycaster ]# pwd/[root@skycaster ]# lsbin home mnt sbin usrdev lib proc sys varetc lost+found root tmp测试环境@系统: Windows 7 Professional with SP1@Vivado: 2015.04@虚拟机: OSRC_Miz7_ubuntu_14@开发板: 米联MIZ702N参考文章(原创)一步一步学ZedBoard &amp; Zynq(七)：制作ZedBoard上linux根文件系统(ramdisk)最新busybox-1.28.1制作根文件系统","categories":[{"name":"xilinx","slug":"xilinx","permalink":"http://balost.github.io/categories/xilinx/"}],"tags":[{"name":"xilinx","slug":"xilinx","permalink":"http://balost.github.io/tags/xilinx/"},{"name":"ramdisk","slug":"ramdisk","permalink":"http://balost.github.io/tags/ramdisk/"},{"name":"linux","slug":"linux","permalink":"http://balost.github.io/tags/linux/"}]},{"title":"ZYNQ 烧录QSPI FLASH及从QSPI启动","slug":"zynq-qspi-02","date":"2018-08-06T06:21:41.000Z","updated":"2018-08-20T01:28:30.000Z","comments":true,"path":"622008616/","link":"","permalink":"http://balost.github.io/622008616/","excerpt":"ZYNQ Linux启动方式由于ZYNQ采用的是PS(ARM A9双核)+PL(FPGA)设计, 整个启动过程比较复杂, 因此我们从嵌入式Linux软件层面的角度考虑, 将ZYNQ当作一块纯ARM开发板, 从而简化ZYNQ的启动流程.SD卡和QSPI启动流程ZYNQ跑Linux系统, 在实际情况中用得比较多的启动方法为SD卡启动和QSPI启动, 先看下这两种方式的启动流程:","text":"ZYNQ Linux启动方式由于ZYNQ采用的是PS(ARM A9双核)+PL(FPGA)设计, 整个启动过程比较复杂, 因此我们从嵌入式Linux软件层面的角度考虑, 将ZYNQ当作一块纯ARM开发板, 从而简化ZYNQ的启动流程.SD卡和QSPI启动流程ZYNQ跑Linux系统, 在实际情况中用得比较多的启动方法为SD卡启动和QSPI启动, 先看下这两种方式的启动流程:QSPI启动123456设置板子为QSPI启动 ----&gt; 上电启动 ---&gt; 从Flash加载BOOT.bin(fsbl.elf, system.bit, u-boot.elf) ---&gt; 进入U-BOOT ---&gt; 解析bootargs(将kernel, devicetree, ramdisk 从Flash加载到内存指定地址) ---&gt; 使用bootm命令启动LinuxSD卡启动123456设置板子为SD卡启动 ----&gt; 上电启动 ---&gt; 从SD卡加载BOOT.bin(fsbl.elf, system.bit, u-boot.elf) ---&gt; 进入U-BOOT ---&gt; 解析bootargs(将kernel, devicetree, ramdisk 从SD卡加载到内存指定地址) ---&gt; 使用bootm命令启动LinuxSD卡和QSPI启动Linux的bootargsU-boot中这两种启动方式的boottargs定义:[src]bootloader/include/configs/zynq-common.h12345678910111213141516171819202122232425262728293031...\"kernel_image=uImage\\0\" \\\"kernel_load_address=0x2080000\\0\" \\\"ramdisk_image=uramdisk.image.gz\\0\" \\\"ramdisk_load_address=0x4000000\\0\" \\\"devicetree_image=devicetree.dtb\\0\" \\\"devicetree_load_address=0x2000000\\0\" \\\"bitstream_image=system.bit.bin\\0\" \\\"boot_image=BOOT.bin\\0\" \\...\"kernel_size=0x500000\\0\" \\\"devicetree_size=0x20000\\0\" \\\"ramdisk_size=0x800000\\0\"...\"qspiboot=echo Copying Linux from QSPI flash to RAM... &amp;&amp; \" \\ \"sf probe 0 0 0 &amp;&amp; \" \\ \"sf read $&#123;kernel_load_address&#125; 0x500000 $&#123;kernel_size&#125; &amp;&amp; \" \\ \"sf read $&#123;devicetree_load_address&#125; 0xA00000 $&#123;devicetree_size&#125; &amp;&amp; \" \\ \"echo Copying ramdisk... &amp;&amp; \" \\ \"sf read $&#123;ramdisk_load_address&#125; 0xA20000 $&#123;ramdisk_size&#125; &amp;&amp; \" \\ \"bootm $&#123;kernel_load_address&#125; $&#123;ramdisk_load_address&#125; $&#123;devicetree_load_address&#125;\\0\" \\...\"sdboot=if mmcinfo; then \" \\ \"run uenvboot; \" \\ \"echo Copying Linux from SD to RAM... &amp;&amp; \" \\ \"load mmc 0 $&#123;kernel_load_address&#125; $&#123;kernel_image&#125; &amp;&amp; \" \\ \"load mmc 0 $&#123;devicetree_load_address&#125; $&#123;devicetree_image&#125; &amp;&amp; \" \\ \"load mmc 0 $&#123;ramdisk_load_address&#125; $&#123;ramdisk_image&#125; &amp;&amp; \" \\ \"bootm $&#123;kernel_load_address&#125; $&#123;ramdisk_load_address&#125; $&#123;devicetree_load_address&#125;; \" \\ \"fi\\0\" \\...分别看下u-boot中sf和load命令:12345678// sf: 用于spi/qspi flash的读/写/擦除操作;// read/write/erase之前必须先调用sf probe;// 具体用法:sf probe [[bus:]cs] [hz] [mode] - init flash device on given SPI bus and chip selectsf read addr offset len - read `len' bytes starting at`offset' to memory at `addr'sf write addr offset len - write `len' bytes from memor at `addr' to flash at `offset'sf erase offset [+]len - erase `len' bytes from `offset' `+len' round up `len' to block sizesf update addr offset len - erase and write `len' bytes from memory at `addr' to flash at `offset'12345678910// load: 用于读取文件系统中的二进制文件;// 从SD卡启动, mmc 0 为SD卡;// 具体用法:load &lt;interface&gt; [&lt;dev[:part]&gt; [&lt;addr&gt; [&lt;filename&gt; [bytes [pos]]]]] - Load binary file 'filename' from partition 'part' on device type 'interface' instance 'dev' to address 'addr' in memory. 'bytes' gives the size to load in bytes. If 'bytes' is 0 or omitted, the file is read until the end. 'pos' gives the file byte position to start reading from. If 'pos' is 0 or omitted, the file is read from the start.通过对比我们可以看出SD卡和QSPI启动Linux的区别主要在于:前者从SD卡中将uImage, uramdisk.image.gz, devicetree.dtb文件加载到内存指定位置, 而后者从qspi flash 指定地址(分区)中加载到内存.Tips:qspiboot中读取Flash时使用的三个地址偏移0x500000, 0xA00000, 0xA20000, 需要根据实际情况进行配置.QSPI FLASH烧录U-boot下烧录SD卡启动文件到QSPI Flash设置板子为SD卡启动, 上电后进入U-boot命令行:123456789101112131415161718Zynq&gt; ls mmc 0 # 查看SD卡目录结构;Zynq&gt; sf probe 0 0 0 # 初始化SPI FLASH Zynq&gt; fatload mmc 0 0x08000000 BOOT.bin # 从SD卡加载BOOT.bin到内存地址0x08000000;Zynq&gt; sf erase 0x0 0x500000 # 擦除Flash 0x0地址处大小为0x500000的空间;Zynq&gt; sf write 0x8000000 0x0 0x500000 # 将内存地址0x08000000起始处的0x500000的大小内容写进Flash地址0x0处; Zynq&gt; fatload mmc 0 0x08000000 uImage # 从SD卡加载uImage到内存地址0x08000000;Zynq&gt; sf erase 0x500000 0x500000 # 擦除Flash 0x500000地址处大小为0x500000的空间;Zynq&gt; sf write 0x8000000 0x500000 0x500000 # 将内存地址0x08000000起始处的0x500000的大小内容写进Flash地址0x500000处; Zynq&gt; fatload mmc 0 0x08000000 devicetree.dtb # 从SD卡加载devicetree.dtb到内存地址0x08000000;Zynq&gt; sf erase 0xA00000 0x20000 # 擦除Flash 0xA00000地址处大小为0x20000的空间;Zynq&gt; sf write 0x8000000 0xA00000 0x20000 # 将内存地址0x08000000起始处的0x20000的大小内容写进Flash地址0xA00000处; Zynq&gt; fatload mmc 0 0x08000000 uramdisk.image.gz # 从SD卡加载uramdisk.image.gz到内存地址0x08000000;Zynq&gt; sf erase 0xA20000 0x800000 # 擦除Flash 0xA20000地址处大小为0x500000的空间;Zynq&gt; sf write 0x8000000 0xA20000 0x800000 # 将内存地址0x08000000起始处的0x800000的大小内容写进Flash地址0xA20000处;设置板子为QSPI启动, 重新上电, 成功进入系统.制作QSPI启动镜像直接烧写SD卡启动文件似乎有点复杂, 那么我们就制作单独的QSPI启动镜像文件, 简化烧录过程; 首先我们看看制作SD卡启动文件脚本的主要内容:scripts/mk_sd_image.sh123456789101112131415...echo \"//arch = zynq; split = false; format = BIN\" &gt; $&#123;TARGET&#125;/sd_image.bifecho \"the_ROM_image:\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \"&#123;\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \" [bootloader]$&#123;TARGET&#125;/fsbl.elf\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \" $&#123;TARGET&#125;/system_wrapper.bit\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \" $&#123;TARGET&#125;/u-boot.elf\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \"&#125;\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bif...bootgen -image $&#123;TARGET&#125;/sd_image.bif -o $&#123;IMAGES&#125;/sd_image/BOOT.bin -w on...cp -a $&#123;TARGET&#125;/uImage $&#123;IMAGES&#125;/sd_image/cp -a $&#123;TARGET&#125;/devicetree.dtb $&#123;IMAGES&#125;/sd_image/cp -a $&#123;TARGET&#125;/uramdisk.image.gz $&#123;IMAGES&#125;/sd_image/...从这一段内容可以看出BOOT.bin是由sd_image.bif打包生成的; 而sd_image.bif是由fsbl.elf, system_wrapper.bit, boot.elf三个文件组成, 基本格式为:123456the_ROM_image:&#123; [bootloader]fsbl.elf system_wrapper.bit boot.elf&#125;剩下的uImage, devicetree.dtb, uramdisk.image.gz则是直接拷贝过来的; 那么我们将bif文件的格式加入偏移后变成:123456789the_ROM_image:&#123; [bootloader]fsbl.elf system_wrapper.bit boot.elf [offset = 0x500000]uImage.bin [offset = 0xA00000]devicetree.dtb [offset = 0xA20000]uramdisk.image.gz&#125;这样就将所有需要的启动文件打包成一个文件.Tips:注意这里的offset要与bootargs中的偏移一致才能正确读取各个部分内容.修改mk_sd_image.sh的内容, 保存为mk_qspi_image.sh[src]scripts/mk_qspi_image.sh12345678910111213141516171819202122232425...BIF_FILE=$&#123;TARGET&#125;/qspi_image.bif# startecho \"//arch = zynq; split = false; format = BIN\" &gt; $&#123;BIF_FILE&#125;echo \"the_ROM_image:\" &gt;&gt;$&#123;BIF_FILE&#125;echo \"&#123;\" &gt;&gt;$&#123;BIF_FILE&#125;# The files we need are:# 1. the first stage boot loaderecho \" [bootloader]$&#123;TARGET&#125;/fsbl.elf\" &gt;&gt;$&#123;BIF_FILE&#125;# 2. FPGA bit streamif [ -f \"$&#123;TARGET&#125;/system_wrapper.bit\" ]; then echo \" $&#123;TARGET&#125;/system_wrapper.bit\" &gt;&gt;$&#123;BIF_FILE&#125;fi# 3. Das U-Boot boot loaderecho \" $&#123;TARGET&#125;/u-boot.elf\" &gt;&gt;$&#123;BIF_FILE&#125;# 4. Linux kernel with modified header for U-Bootecho \" [offset = 0x500000]$&#123;TARGET&#125;/uImage.bin\" &gt;&gt;$&#123;BIF_FILE&#125;# 5. Device tree blobecho \" [offset = 0xA00000]$&#123;TARGET&#125;/devicetree.dtb\" &gt;&gt;$&#123;BIF_FILE&#125;# 6. Root filesystemecho \" [offset = 0xA20000]$&#123;TARGET&#125;/uramdisk.image.gz\" &gt;&gt;$&#123;BIF_FILE&#125;echo \"&#125;\" &gt;&gt;$&#123;BIF_FILE&#125;# endbootgen -image $&#123;TARGET&#125;/qspi_image.bif -o $&#123;IMAGES&#125;/qspi_image/qspi_image.bin -w on...执行以下脚本生成image/qspi_image/qspi_image.bin, 文件大小接近18MB.1# mk_bootloader.sh &amp;&amp; mk_kernel.sh &amp;&amp; mk_qspi_image.sh烧录时执行以下命令即可:123Zynq&gt; fatload mmc 0 0x08000000 qspi_image.bin # 从SD卡加载qspi_image.bin到内存地址0x08000000;Zynq&gt; sf erase 0x0 0x1200000 # 擦除Flash 0x0地址处大小为0x1200000的空间;Zynq&gt; sf write 0x8000000 0x0 0x1200000 # 将内存地址0x08000000起始处的0x1200000的大小内容写进Flash地址0x0处;启动Linux后烧录启动文件到QSPI Flash在Linux下可以将bin文件通过dd 命令直接写进Flash中. 首先要配置QSPI Flash驱动, 生成MTD设备节点. 在Kernel源码路径输入命令:1# make ARCH=arm menuconfig选择以下配置选项:12345678Device Drivers ---&gt; &lt;*&gt; Memory Technology Device (MTD) support ---&gt; Self-contained MTD device drivers ---&gt; &lt;*&gt; Support most SPI Flash chips (AT26DF, M25P, W25X, ...) &lt;*&gt; SPI-NOR device support ---&gt; [*] SPI support ---&gt; &lt;*&gt; Xilinx SPI controller common module &lt;*&gt; Xilinx Zynq QSPI controller修改设备树:[src]kernel/arch/arm/boot/dts/zynq-zed.dts12345678910111213141516171819202122 ... aliases &#123; ... spi0 = &amp;qspi; ... &#125;; ...&amp;qspi &#123; status = &quot;okay&quot;; is-dual = &lt;0&gt;; num-cs = &lt;1&gt;; flash@0 &#123; compatible = &quot;n25q128a11&quot;; reg = &lt;0x0&gt;; spi-tx-bus-width = &lt;1&gt;; spi-rx-bus-width = &lt;4&gt;; spi-max-frequency = &lt;50000000&gt;; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; &#125;;&#125;;...在flash子节点下可以自己添加分区, 格式为[src]kernel/arch/arm/boot/dts/zynq-zed.dts12345678910111213141516partition@qspi-fsbl-uboot &#123; label = &quot;qspi-fsbl-uboot&quot;; reg = &lt;0x0 0x500000&gt;;&#125;;partition@qspi-linux &#123; label = &quot;qspi-linux&quot;; reg = &lt;0x500000 0x500000&gt;;&#125;;partition@qspi-device-tree &#123; label = &quot;qspi-device-tree&quot;; reg = &lt;0xA00000 0x20000&gt;; &#125;;partition@qspi-rootfs &#123; label = &quot;qspi-rootfs&quot;; reg = &lt;0xA20000 0x800000&gt;;&#125;;执行以下脚本生成qspi_image.bin:1# mk_bootloader.sh &amp;&amp; mk_kernel.sh &amp;&amp; mk_qspi_image.sh拷贝生成文件到SD卡, 上电启动, 进入系统, 查看设备节点和MTD分区信息:12345# ls /dev/mtd*/dev/mtd0 /dev/mtd0ro /dev/mtdblock0# cat /proc/mtd dev: size erasesize namemtd0: 02000000 00010000 &quot;spi0.0&quot;使用dd命令烧录QSPI Flash:123# dd if=&lt;sdcard_root_dir&gt;/qspi_image.bin of=/dev/mtdblock0 bs=102417687+1 records in17687+1 records out重新启动开发板, 进入系统, OK.测试环境@系统: Windows 7 Professional with SP1@Vivado: 2015.04@虚拟机: OSRC_Miz7_ubuntu_14@开发板: 米联MIZ702N参考文章[移植篇] CH04 LINUX从QSPI启动","categories":[{"name":"xilinx","slug":"xilinx","permalink":"http://balost.github.io/categories/xilinx/"}],"tags":[{"name":"xilinx","slug":"xilinx","permalink":"http://balost.github.io/tags/xilinx/"},{"name":"qspi","slug":"qspi","permalink":"http://balost.github.io/tags/qspi/"}]},{"title":"ZYNQ QSPI驱动分析","slug":"zynq-qspi-01","date":"2018-08-03T03:52:41.000Z","updated":"2018-08-20T01:28:35.872Z","comments":true,"path":"1064320173/","link":"","permalink":"http://balost.github.io/1064320173/","excerpt":"ZYNQ QSPI框架接口首先, 我们要知道: SPI Nor层完成MTD子系统的接口和Norflash操作硬件接口的转化, 而SPI Master层完成操作硬件时数据传输的协议制定.那么一次读写Norflash过程可以简化为:1234file system(open, read, write) -&gt; mtd sub system(mtd_open, mtd_read, mtd_write) -&gt; nor flash(m25p80_read, m25p80_write) -&gt; hardware","text":"ZYNQ QSPI框架接口首先, 我们要知道: SPI Nor层完成MTD子系统的接口和Norflash操作硬件接口的转化, 而SPI Master层完成操作硬件时数据传输的协议制定.那么一次读写Norflash过程可以简化为:1234file system(open, read, write) -&gt; mtd sub system(mtd_open, mtd_read, mtd_write) -&gt; nor flash(m25p80_read, m25p80_write) -&gt; hardware再来看下整个qspi框架的主要接口:12345678910111213----------------|------------------------------------------------------------MTD Sub System |----------------|------------------------------------------------------------ | spi_nor_read spi_nor_write spi_nor_lock spi_nor_unlockSPI Nor |------------------------------------------------------------ | m25p80_read m25p80_write m25p80_read_reg m25p80_write_reg----------------|------------------------------------------------------------ | spi_write spi_sync spi_write_then_readSPI Master |------------------------------------------------------------ | zynq_qspi_setup zynq_qspi_start_transfer----------------|------------------------------------------------------------Hardware |----------------|------------------------------------------------------------ZYNQ QSPI驱动注册过程QSPI驱动主要分为2个部分: SPI Master部分完成主控的硬件初始化以及配置SPI总线地址, 位宽, 模式, 速度等; Norflash部分实现了操作Flash硬件的接口和MTD子系统的读/写/擦除Flash接口.SPI Master驱动注册在驱动入口函数zynq_qspi_probe中, 完成对QSPI主控制器的一系列初始化:[src]driver/spi/spi-zynq-qspi.c123456789101112static int zynq_qspi_probe(struct platform_device *pdev)&#123; ... /* QSPI controller initializations */ zynq_qspi_init_hw(xqspi); ... master-&gt;setup = zynq_qspi_setup; master-&gt;set_cs = zynq_qspi_chipselect; master-&gt;transfer_one = zynq_qspi_start_transfer; master-&gt;prepare_transfer_hardware = zynq_prepare_transfer_hardware; ...&#125;最后调用spi_register_master()创建设备节点/dev/spiX.X[src]driver/spi/spi-zynq-qspi.c12345678910static int zynq_qspi_probe(struct platform_device *pdev)&#123; ... ret = spi_register_master(master); if (ret) &#123; dev_err(&amp;pdev-&gt;dev, \"spi_register_master failed\\n\"); goto clk_dis_all; &#125; ...&#125;在spi_register_master函数的最后, 调用了of_register_spi_device来遍历子节点[src]driver/spi/spi.c1234567int spi_register_master(struct spi_master *master)&#123; ... /* Register devices from the device tree and ACPI */ of_register_spi_devices(master); ...&#125;在该函数中读取设备树上的配置信息, 初始化SPI BUS[src]driver/spi/spi.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static void of_register_spi_devices(struct spi_master *master)&#123; ... /* Alloc an spi_device */ spi = spi_alloc_device(master); ... /* Select device driver */ rc = of_modalias_node(nc, spi-&gt;modalias, sizeof(spi-&gt;modalias)); ... /* Device address */ rc = of_property_read_u32(nc, \"reg\", &amp;value); spi-&gt;chip_select = value; ... /* Mode (clock phase/polarity/etc.) */ if (of_find_property(nc, \"spi-cpha\", NULL)) spi-&gt;mode |= SPI_CPHA; if (of_find_property(nc, \"spi-cpol\", NULL)) spi-&gt;mode |= SPI_CPOL; if (of_find_property(nc, \"spi-cs-high\", NULL)) spi-&gt;mode |= SPI_CS_HIGH; if (of_find_property(nc, \"spi-3wire\", NULL)) spi-&gt;mode |= SPI_3WIRE; if (of_find_property(nc, \"spi-lsb-first\", NULL)) spi-&gt;mode |= SPI_LSB_FIRST; /* Device DUAL/QUAD mode */ if (!of_property_read_u32(nc, \"spi-tx-bus-width\", &amp;value)) &#123; switch (value) &#123; case 1: break; case 2: spi-&gt;mode |= SPI_TX_DUAL; break; case 4: spi-&gt;mode |= SPI_TX_QUAD; break; default: dev_warn(&amp;master-&gt;dev, \"spi-tx-bus-width %d not supported\\n\", value); break; &#125; &#125; if (!of_property_read_u32(nc, \"spi-rx-bus-width\", &amp;value)) &#123; switch (value) &#123; case 1: break; case 2: spi-&gt;mode |= SPI_RX_DUAL; break; case 4: spi-&gt;mode |= SPI_RX_QUAD; break; default: dev_warn(&amp;master-&gt;dev, \"spi-rx-bus-width %d not supported\\n\", value); break; &#125; &#125; /* Device speed */ rc = of_property_read_u32(nc, \"spi-max-frequency\", &amp;value); spi-&gt;max_speed_hz = value; ...&#125;Norflash驱动注册在of_register_spi_device函数的最后, 调用spi_add_device来加载m25p80设备驱动[src]driver/spi/spi.c1234567static void of_register_spi_devices(struct spi_master *master)&#123; ... /* Register the new device */ rc = spi_add_device(spi); ...&#125;在m25p_probe函数中, 配置spi nor的read/write(读写nor flash), read_reg(配置qspi寄存器), write_reg(配置nor flash寄存器)[src]drivers/mtd/devices/m25p80.c123456789static int m25p_probe(struct spi_device *spi)&#123; ... nor-&gt;read = m25p80_read; nor-&gt;write = m25p80_write; nor-&gt;write_reg = m25p80_write_reg; nor-&gt;read_reg = m25p80_read_reg; ...&#125;调用spi_nor_scan函数, 获取id, 得到nor flash信息, 然后配置type, writesize, size等参数, 设置_erase, _read, _write回调函数[src]drivers/mtd/devices/m25p80.c1234567891011121314int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)&#123; ... jinfo = spi_nor_read_id(nor); ... mtd-&gt;priv = nor; mtd-&gt;type = MTD_NORFLASH; mtd-&gt;writesize = 1; mtd-&gt;flags = MTD_CAP_NORFLASH; mtd-&gt;size = info-&gt;sector_size * info-&gt;n_sectors; mtd-&gt;_erase = spi_nor_erase; mtd-&gt;_read = spi_nor_read_ext; ...&#125;调用mtd_device_register函数, 解析设备树中的分区表, 添加分区信息[src]drivers/mtd/mtdcore.c1234567891011int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types, struct mtd_part_parser_data *parser_data, const struct mtd_partition *parts, int nr_parts)&#123; ... ret = parse_mtd_partitions(mtd, types, &amp;parsed, parser_data); ... ret = mtd_add_device_partitions(mtd, &amp;parsed); ...&#125;参考文章Linux SPI/QSPI nor flash相关驱动代码","categories":[{"name":"xilinx","slug":"xilinx","permalink":"http://balost.github.io/categories/xilinx/"}],"tags":[{"name":"xilinx","slug":"xilinx","permalink":"http://balost.github.io/tags/xilinx/"},{"name":"qspi","slug":"qspi","permalink":"http://balost.github.io/tags/qspi/"}]}]}