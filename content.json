{"meta":{"title":"BALOST","subtitle":null,"description":null,"author":"BALOST","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-07-23T03:56:24.000Z","updated":"2018-07-23T04:21:16.843Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-23T04:23:23.000Z","updated":"2018-07-23T04:29:24.325Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ZYNQ QSPI驱动分析","slug":"zynq-qspi-01","date":"2018-08-03T03:52:41.000Z","updated":"2018-08-03T09:22:40.326Z","comments":true,"path":"1064320173/","link":"","permalink":"http://yoursite.com/1064320173/","excerpt":"","text":"ZYNQ QSPI框架接口12345678910111213----------------|------------------------------------------------------------MTD Sub System |----------------|------------------------------------------------------------ | spi_nor_read spi_nor_write spi_nor_lock spi_nor_unlockSPI Nor |------------------------------------------------------------ | m25p80_write m25p80_read m25p80_write_reg m25p80_read_reg----------------|------------------------------------------------------------SPI Bus | spi_write spi_sync spi_write_then_read----------------|------------------------------------------------------------SPI Master | zynq_qspi_setup zynq_qspi_start_transfer----------------|------------------------------------------------------------Hardware |----------------|------------------------------------------------------------ZYNQ QSPI驱动注册过程SPI MASTER 驱动注册在驱动入口函数zynq_qspi_probe中, 完成对QSPI Controller的一系列初始化driver/spi/spi-zynq-qspi.c123456789101112static int zynq_qspi_probe(struct platform_device *pdev)&#123; ... /* QSPI controller initializations */ zynq_qspi_init_hw(xqspi); ... master-&gt;setup = zynq_qspi_setup; master-&gt;set_cs = zynq_qspi_chipselect; master-&gt;transfer_one = zynq_qspi_start_transfer; master-&gt;prepare_transfer_hardware = zynq_prepare_transfer_hardware; ...&#125;最后调用spi_register_master()创建设备节点/dev/spiX.Xdriver/spi/spi-zynq-qspi.c12345678910static int zynq_qspi_probe(struct platform_device *pdev)&#123; ... ret = spi_register_master(master); if (ret) &#123; dev_err(&amp;pdev-&gt;dev, \"spi_register_master failed\\n\"); goto clk_dis_all; &#125; ...&#125;SPI BUS 驱动注册在spi_register_master函数的最后, 调用了of_register_spi_device来遍历子节点driver/spi/spi.c1234567int spi_register_master(struct spi_master *master)&#123; ... /* Register devices from the device tree and ACPI */ of_register_spi_devices(master); ...&#125;在该函数中读取设备树上的配置信息, 初始化SPI BUSdriver/spi/spi.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static void of_register_spi_devices(struct spi_master *master)&#123; ... /* Alloc an spi_device */ spi = spi_alloc_device(master); ... /* Select device driver */ rc = of_modalias_node(nc, spi-&gt;modalias, sizeof(spi-&gt;modalias)); ... /* Device address */ rc = of_property_read_u32(nc, \"reg\", &amp;value); spi-&gt;chip_select = value; ... /* Mode (clock phase/polarity/etc.) */ if (of_find_property(nc, \"spi-cpha\", NULL)) spi-&gt;mode |= SPI_CPHA; if (of_find_property(nc, \"spi-cpol\", NULL)) spi-&gt;mode |= SPI_CPOL; if (of_find_property(nc, \"spi-cs-high\", NULL)) spi-&gt;mode |= SPI_CS_HIGH; if (of_find_property(nc, \"spi-3wire\", NULL)) spi-&gt;mode |= SPI_3WIRE; if (of_find_property(nc, \"spi-lsb-first\", NULL)) spi-&gt;mode |= SPI_LSB_FIRST; /* Device DUAL/QUAD mode */ if (!of_property_read_u32(nc, \"spi-tx-bus-width\", &amp;value)) &#123; switch (value) &#123; case 1: break; case 2: spi-&gt;mode |= SPI_TX_DUAL; break; case 4: spi-&gt;mode |= SPI_TX_QUAD; break; default: dev_warn(&amp;master-&gt;dev, \"spi-tx-bus-width %d not supported\\n\", value); break; &#125; &#125; if (!of_property_read_u32(nc, \"spi-rx-bus-width\", &amp;value)) &#123; switch (value) &#123; case 1: break; case 2: spi-&gt;mode |= SPI_RX_DUAL; break; case 4: spi-&gt;mode |= SPI_RX_QUAD; break; default: dev_warn(&amp;master-&gt;dev, \"spi-rx-bus-width %d not supported\\n\", value); break; &#125; &#125; /* Device speed */ rc = of_property_read_u32(nc, \"spi-max-frequency\", &amp;value); spi-&gt;max_speed_hz = value; ...&#125;SPI NOR 驱动注册在of_register_spi_device函数的最后, 调用spi_add_device来加载m25p80设备驱动driver/spi/spi.c1234567static void of_register_spi_devices(struct spi_master *master)&#123; ... /* Register the new device */ rc = spi_add_device(spi); ...&#125;在m25p_probe函数中, 配置spi nor的read/write(读写nor flash), read_reg(配置qspi寄存器), write_reg(配置nor flash寄存器)drivers/mtd/devices/m25p80.c123456789static int m25p_probe(struct spi_device *spi)&#123; ... nor-&gt;read = m25p80_read; nor-&gt;write = m25p80_write; nor-&gt;write_reg = m25p80_write_reg; nor-&gt;read_reg = m25p80_read_reg; ...&#125;调用spi_nor_scan函数, 获取id, 得到nor flash信息, 然后配置type, writesize, size等参数, 设置_erase, _read, _write回调函数drivers/mtd/devices/m25p80.c1234567891011121314int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)&#123; ... jinfo = spi_nor_read_id(nor); ... mtd-&gt;priv = nor; mtd-&gt;type = MTD_NORFLASH; mtd-&gt;writesize = 1; mtd-&gt;flags = MTD_CAP_NORFLASH; mtd-&gt;size = info-&gt;sector_size * info-&gt;n_sectors; mtd-&gt;_erase = spi_nor_erase; mtd-&gt;_read = spi_nor_read_ext; ...&#125;调用mtd_device_register函数, 解析设备树中的分区表, 添加分区信息drivers/mtd/mtdcore.c1234567891011int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types, struct mtd_part_parser_data *parser_data, const struct mtd_partition *parts, int nr_parts)&#123; ... ret = parse_mtd_partitions(mtd, types, &amp;parsed, parser_data); ... ret = mtd_add_device_partitions(mtd, &amp;parsed); ...&#125;参考文章Linux SPI/QSPI nor flash相关驱动代码","categories":[{"name":"xilinx","slug":"xilinx","permalink":"http://yoursite.com/categories/xilinx/"}],"tags":[{"name":"xilinx","slug":"xilinx","permalink":"http://yoursite.com/tags/xilinx/"},{"name":"qspi","slug":"qspi","permalink":"http://yoursite.com/tags/qspi/"}]}]}