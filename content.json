{"meta":{"title":"Work and Learning Journey","subtitle":null,"description":null,"author":"Yuming","url":"http://hanoi404.github.io"},"pages":[{"title":"关于我","date":"2018-08-16T09:51:57.000Z","updated":"2018-08-21T10:40:28.148Z","comments":true,"path":"about/index.html","permalink":"http://hanoi404.github.io/about/index.html","excerpt":"","text":"卧槽, 这扑街真懒, 什么都没写, 得好好安排一下."},{"title":"分类","date":"2018-07-23T03:56:24.000Z","updated":"2018-08-20T08:43:18.314Z","comments":false,"path":"categories/index.html","permalink":"http://hanoi404.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-23T04:23:23.000Z","updated":"2018-08-20T08:43:52.745Z","comments":true,"path":"tags/index.html","permalink":"http://hanoi404.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Qt 静态编译(基于Windows MinGW 版)","slug":"qt-static-compile","date":"2019-07-08T10:01:52.000Z","updated":"2019-07-09T00:57:31.749Z","comments":true,"path":"1519021197/","link":"","permalink":"http://hanoi404.github.io/1519021197/","excerpt":"编译环境Qt source: 5.13.0操作系统: windows 7 SP1 64-bit编译工具: minGW730 32-bit目标版本: minGW730 32-bit static","text":"编译环境Qt source: 5.13.0操作系统: windows 7 SP1 64-bit编译工具: minGW730 32-bit目标版本: minGW730 32-bit static编译准备安装 Qt目录盘符修改为D盘, 选择安装MinGW 7.3.0 32 bit, TOOLS下的MinGW 7.3.0 32 bit, 以及Strawberry Perl, Src不建议直接安装, 浪费时间, 直接官网下载单独的源码包解压就行 下载地址.添加到 MinGW 环境变量首先, 需要将 MinGW 编译工具添加到环境变量中, 如果你按照我的安装路径的话,应该是D:\\Qt\\Qt5.13.0\\Tools\\mingw730_32\\bin. 把该路径添加到环境变量中, 最好放到最前面.安装Python网上下载安装包直接安装即可, 注意选择添加到环境变量.解压Qt Source目录结构假设当前盘符为 D, 创建以下目录结构Qtqt-everywhere-src-5.13.0mingw73_32_staticmingw73_32_static_install其中 qt-everywhere-src-5.13.0 为源码解压后的目录, mingw73_32_static 和 mingw73_32_static_install 分别为编译和安装目录.开始编译从开始菜单选择运行 Qt 5.13 for Desktop (MinGW 7.3.0 32 bit)进入到 mingw73_32_static 目录:123cd dcd Qtcd mingw73_32_static输入以下命令进行配置, 我这里配置只编译了 Release 版本, 跳过了编译 examples 和 tests, -prefix安装路径根据自己的进行修改:1D:\\Qt\\qt-everywhere-src-5.13.0\\configure.bat -confirm-license -opensource -opengl desktop -platform win32-g++ -mp -release -static -static-runtime -prefix \"D:\\Qt\\mingw73_32_static_install\" -nomake examples -nomake tests编译和安装, -j4 表示使用 3 线程进行编译, 根据各机器修改, 编译的时间有点长:12mingw32-make -j4mingw32-make install以上流程完成后, 在 mingw73_32_static_install 目录下生成已经编译好的 Qt SDK 库配置 Qt Creator目录迁移将 mingw73_32_static_install 目录原来 Qt 的安装目录下, 目录名称修改为 mingw73_32_static, 我的 Qt 安装在 D 盘, 所以迁移后路径为 D:\\Qt\\Qt5.13.0\\5.13.0\\mingw73_32_static.文件替换一般来说, 编译生成的目录路径是不能更改的, 但我们已经改变了路径, 就要做相应的修改, 这里使用比较简单的一种改法: 在安装时勾选了 MinGW 7.3.0 32-bit(不是 Tools 中的), 那么在应该存在 D:\\Qt\\Qt5.13.0\\5.13.0\\mingw73_32 这个目录, 将此目录下的 bin 文件夹中的 qmlscene.exe 和 qt.confqt.conf 拷贝到D:\\Qt\\Qt5.13.0\\5.13.0\\mingw73_32_static\\bin 目录下覆盖原文件即可.Qt Creator 中使用打开 工具-&gt;选项-&gt;Kits-&gt;Qt Versions-&gt;添加, 选择 D:\\Qt\\Qt5.13.0\\5.13.0\\mingw73_32_static\\bin\\qmake.exe文件.克隆 Kit 下的 Desktop Qt 5.13.0 MinGW 32-bit, 修改下 名称, Qt version 选择上一步新建的版本.打开或新建一个项目, 在 项目-&gt;Build &amp; Run， 中选择新添加的 Kit, 编译并运行即可.云盘备份百度云","categories":[{"name":"Qt","slug":"Qt","permalink":"http://hanoi404.github.io/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://hanoi404.github.io/tags/Qt/"},{"name":"MinGW","slug":"MinGW","permalink":"http://hanoi404.github.io/tags/MinGW/"}]},{"title":"C# 下 CRC32 算法的实现","slug":"cs-crc32","date":"2019-06-26T01:17:46.000Z","updated":"2019-06-26T01:39:09.394Z","comments":true,"path":"880640044/","link":"","permalink":"http://hanoi404.github.io/880640044/","excerpt":"CRC32CRC 的全称是循环冗余校验. 通常用于检查传输的数据是否完整.","text":"CRC32CRC 的全称是循环冗余校验. 通常用于检查传输的数据是否完整.生成 CRC32 校验表首先来看 CRC32 的生成多项式：1CRC32=X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+1由此得到多项式值为 0x04C11DB7 ，忽略了最高位的 1，即完整的多项式值是 0x104C11DB7 , 根据这个多项式值得到反转多项式值 0xEDB88320 (反转多项式: 在数据通讯时, 信息字节先传送或接受低位字节, 如重新排列则影响速度), 这时，就可以使用该反转多项式值来生成 CRC32 校验表了:12345678910111213141516171819202122public void GetCRC32Table() //生成CRC32码表&#123; UInt32 Crc; crcTable = new UInt32[256]; int i, j; for (i = 0; i &lt; 256; i++) &#123; Crc = (UInt32)i; for (j = 8; j &gt; 0; j--) &#123; if ((Crc &amp; 1) == 1) &#123; Crc = (Crc &gt;&gt; 1) ^ 0xEDB88320; // 0x04C11DB7 位逆转得到 0xEDB88320. &#125; else &#123; Crc &gt;&gt;= 1; &#125; &#125; crcTable[i] = Crc; &#125;&#125;查表法的实现查表法实现 CRC 校验, 具体步骤如下:将上次计算出的 CRC 校验码右移一个字节;将移出的这个字节与新的要校验的字节进行 XOR 运算;用运算出的值在预先生成码表中进行索引, 获取对应的值(称为余式);用获取的值与第 1 步右移后的值进行 XOR 运算；如果要校验的数据已经处理完, 则第 4 步的结果就是最终的CRC校验码.如果还有数据要进行处理, 则再转到第 1 步运行.示例代码:12345678910public uint GetCRC32(byte[] bytes)&#123; uint iCount = (uint)bytes.Length; uint crc = 0xFFFFFFFF; for (uint i = 0; i &lt; iCount; i++) &#123; crc = (crc &gt;&gt; 8) ^ crcTable[(crc ^ bytes[i]) &amp; 0xFF]; &#125; return (crc ^ 0xFFFFFFFF);&#125;CPP 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;// 位逆转static uint32_t BitReverse(const uint32_t &amp;input, const int &amp;bit_width) &#123; uint32_t var = 0; for (int i = 0; i &lt; bit_width; ++i) &#123; if (input &amp; 0x1) &#123; var |= 1 &lt;&lt; (bit_width-1-i); &#125; input &gt;&gt;= 1; &#125; return var;&#125;// 码表生成void Crc32Init(const uint32_t &amp;poly, uint32_t *table) &#123; uint32_t crc; uint32_t poly_reverse = BitReverse(poly, 32); for (uint32_t i = 0; i &lt; 256; ++i) &#123; crc = i; for (int j = 0; j &lt; 8; ++j) &#123; if (crc&amp;0x1 == 1) &#123; crc = (crc&gt;&gt;1) ^ poly_reverse; &#125; else &#123; crc = crc&gt;&gt;1; &#125; &#125; table[i] = crc; &#125;&#125;uint32_t Crc32(const char *input, const int &amp;len) &#123; uint32_t table[256] = &#123;0&#125;; uint32_t crc = 0xFFFFFFFF; Crc32Init(0x4C11DB7, table); for (uint8_t i = 0; i &lt; len; ++i) &#123; crc = (crc&gt;&gt;8) ^ table[(crc^input[i]) &amp; 0xFF]; &#125; return (crc ^ 0xFFFFFFFF);&#125;int main(void) &#123; uint32_t crc = Crc32(\"1234567890\", 10); printf(\"CRC32 = %08X\\n\", crc); return 0;&#125;参考内容crc32 算法与实现","categories":[{"name":"C#","slug":"C","permalink":"http://hanoi404.github.io/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hanoi404.github.io/tags/C/"},{"name":"CRC32","slug":"CRC32","permalink":"http://hanoi404.github.io/tags/CRC32/"}]},{"title":"C# 下 JSON 格式数据的解析与生成","slug":"cs-json","date":"2019-06-26T00:58:04.000Z","updated":"2019-06-26T01:34:17.826Z","comments":true,"path":"3650545541/","link":"","permalink":"http://hanoi404.github.io/3650545541/","excerpt":"JSON 简介JSON 是一种数据格式, 不是一种编程语言, 而且是 JavaScript 的语法的子集.支持两种数据类型: 第一种是 JavaScript 中的基本类型(除了undefined外); 第二种是数组和对象(不支持函数).","text":"JSON 简介JSON 是一种数据格式, 不是一种编程语言, 而且是 JavaScript 的语法的子集.支持两种数据类型: 第一种是 JavaScript 中的基本类型(除了undefined外); 第二种是数组和对象(不支持函数).下载与配置手动进行解析比较麻烦, 因此使用开源的类库 Newtonsoft.Json (下载地址) . 下载后 在项目工程中添加 Newtonsoft.Json.dll 引用就能用:1using Newtonsoft.Json;解析下面是一个 JSON 格式内容示例:12345678910111213141516&#123; \"result\": [ &#123; \"Version\": \"1.11.1\", \"FileName\": \"CDRadioFW-Ver1.11.1.bin\", \"Note\": \"CDRadio 1.11.1版本固件\", \"Crc32\": \"2142964168\" &#125;, &#123; \"Version\": \"1.11.2\", \"FileName\": \"CDRadioFW-Ver1.11.2.bin\", \"Note\": \"CDRadio 1.11.2 版本固件\", \"Crc32\": \"-1753905049\" &#125; ]&#125;根据以上 JSON 格式数据设计类:123456789101112public class FirmwareInfo&#123; public string Version &#123; get; set; &#125; public string Filename &#123; get; set; &#125; public string Note &#123; get; set; &#125; public string Crc32 &#123; get; set; &#125;&#125; public class FirmwareInfoList&#123; public List&lt;FirmwareInfo&gt; result &#123; get; set; &#125;&#125;类成员变量名称与 JSON 格式数据中的 Key 必须一致.调用解析代码:12FirmwareInfoList firmwareInfoList = new FirmwareInfoList();firmwareInfoList = JsonConvert.DeserializeObject&lt;FirmwareInfoList&gt;(jsonString);正确解析后 firmwareInfoList 中保存解析出来的数据.生成现假设有一个 WEB 服务器 的API 需要格式为 &quot;Version&quot;:&quot;1.11.1&quot; 的 JSON 格式数据, 据此设计类:1234public class VersionInfo&#123; public string Version &#123; get; set; &#125;&#125;调用生成内容代码:123VersionInfo versionInfo = new VersionInfo();versionInfo.Version = \"1.11.1\";string jsonString = JsonConvert.SerializeObject(versionInfo);得到的 jsonString 内容为 {&quot;Version&quot;: &quot;1.11.1&quot;} .参考内容C#解析JSON字符串总结","categories":[{"name":"C#","slug":"C","permalink":"http://hanoi404.github.io/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hanoi404.github.io/tags/C/"},{"name":".NET","slug":"NET","permalink":"http://hanoi404.github.io/tags/NET/"},{"name":"JSON","slug":"JSON","permalink":"http://hanoi404.github.io/tags/JSON/"}]},{"title":"Linux下常用计时、延时、定时函数","slug":"linux-time","date":"2019-03-16T12:10:48.000Z","updated":"2019-03-16T12:32:48.455Z","comments":true,"path":"860935474/","link":"","permalink":"http://hanoi404.github.io/860935474/","excerpt":"time()函数定义123#include &lt;time.h&gt;time_t time(time_t *tloc);功能: 返回计算机纪元到当前的秒数","text":"time()函数定义123#include &lt;time.h&gt;time_t time(time_t *tloc);功能: 返回计算机纪元到当前的秒数 注意点1. 传递NULL参数来获得返回的时间; 2、传递结构体指针time_t *方式参数, 把结果存放到time_t *中; 3. 只能精确到秒; 使用示例12345678910111213141516171819/* 计算程序运行时间. */#include &lt;iostream&gt;#include &lt;time.h&gt;using namespace std;int main(int argc, char **argv)&#123; int start, stop; start = time(NULL); for (long i = 0; i &lt; 1000000000; ++i) ; stop = time(NULL); cout &lt;&lt; \"second: \" &lt;&lt; (stop - start) &lt;&lt; endl; return 0;&#125;clock()函数定义123#include &lt;time.h&gt; clock_t clock(void);功能: 计算一个程序运行时间 注意点1. clock() 计算的是cpu时间(processor time), 因此在linux环境下不能用于计算sleep()占用的时间; 2. clock() / CLOCKS_PER_SEC 得到秒级为单位的时间, 常量 CLOCKS_PRE_SEC 表示一秒钟会有多少个时钟计时单元; 3. CLOCKS_PRE_SEC 在不同的系统环境中可能定义不一致, 标准POSIX中定义为1000000; 4. 在32位机器上, 运行时间较长(达到72 minutes), 有可能出现计时错误; 使用示例12345678910111213141516171819202122/* 计算程序运行时间. */#include &lt;iostream&gt;#include &lt;time.h&gt;using namespace std;int main(int argc, char **argv)&#123; clock_t clk1, clk2; clk1 = clock(); for (long i = 0; i &lt; 1000000000; ++i) ; clk2 = clock(); cout &lt;&lt; \"CLOCKS_PER_SEC: \" &lt;&lt; CLOCKS_PER_SEC &lt;&lt; endl; cout &lt;&lt; \"raw: \" &lt;&lt; (clk2 - clk1) &lt;&lt; endl; cout &lt;&lt; \"millisecond: \" &lt;&lt; (double)((clk2 - clk1) * 1000 /CLOCKS_PER_SEC) &lt;&lt; endl; cout &lt;&lt; \"second: \" &lt;&lt; (double)((clk2 - clk1)/CLOCKS_PER_SEC) &lt;&lt; endl; return 0;&#125;12345678/* 实现sleep()延时函数. */unsigned int sleep(unsigned int seconds)&#123; clock_t clk = clock(); while (clock() - clk &lt; seconds * CLOCKS_PER_SEC) ; return 0;&#125;alarm()函数定义123#include &lt;unistd.h&gt;unsigned int alarm(unsigned int seconds);功能: 在seconds后产生一个SIGALARM信号 注意点1. seconds为0时, 之前设置的定时器闹钟将被取消, 并将剩下的时间返回; 2. 在seconds秒内再次调用了alarm函数设置了新的闹钟, 则后面定时器的设置将覆盖前面的设置; 3. SIGALARM会中断部分阻塞I/O(epoll_wait()); 4. 只能精确到秒级; 使用示例12345678910111213141516171819202122232425/* 延时执行一个任务. */#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;using namespace std;void alarm_handler(void *arg)&#123; cout &lt;&lt; \"running in alarm handler\" &lt;&lt; endl; return ;&#125;int main(int argc, char **argv)&#123; signal(SIGALRM, (void (*)(int))&amp;alarm_handler); alarm(2); sleep(3); cout &lt;&lt; \"main function end\" &lt;&lt; endl; return 0;&#125;setitime()简介123#include &lt;/sys/time.h&gt;int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);功能: 定时任务或延时任务 注意点1. struct itimerval结构体中it_value设为0, 不会触发信号; 2. struct itimerval结构体中it_interval设为0, 任务仅仅会延时执行一次, 不会定时执行; 3. 在epoll_wait()或sleep()时, 任务不会执行; 使用示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 定时执行一个任务. */#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/time.h&gt;using namespace std;void timer_handler(void)&#123; static int count = 0; cout &lt;&lt; \"count is \" &lt;&lt; count++ &lt;&lt; endl;&#125;void init_sigaction(void)&#123; struct sigaction act; act.sa_handler = (void(*)(int))&amp;timer_handler; act.sa_flags = 0; sigemptyset(&amp;act.sa_mask); sigaction(SIGPROF, &amp;act, NULL);&#125;void init_timer(void)&#123; struct itimerval val; val.it_value.tv_sec = 1; val.it_value.tv_usec = 0; val.it_interval = val.it_value; setitimer(ITIMER_PROF, &amp;val, NULL);&#125;int main(int argc, char **argv)&#123; init_sigaction(); init_timer(); while(1) ; //while(1) sleep(3); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://hanoi404.github.io/categories/C-C/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://hanoi404.github.io/tags/Linux/"},{"name":"C/C++","slug":"C-C","permalink":"http://hanoi404.github.io/tags/C-C/"}]},{"title":"BCD编码方式","slug":"bcd-code","date":"2019-02-05T14:19:09.000Z","updated":"2019-02-07T05:04:51.386Z","comments":true,"path":"4000297480/","link":"","permalink":"http://hanoi404.github.io/4000297480/","excerpt":"BCD编码BCD码是一种二进制的数字编码形式，用二进制编码的十进制代码。这种编码形式利用了4个bit来储存一个十进制的数码，使二进制和十进制之间的转换得以快捷的进行。BCD码常用的有8421码、5421码、2421码和余3码，以下为编码表：","text":"BCD编码BCD码是一种二进制的数字编码形式，用二进制编码的十进制代码。这种编码形式利用了4个bit来储存一个十进制的数码，使二进制和十进制之间的转换得以快捷的进行。BCD码常用的有8421码、5421码、2421码和余3码，以下为编码表：十进制数8421码5421码2421码余3码00000000000000011100010001000101002001000100010010130011001100110110401000100010001115010110001011100060110100111001001701111010110110108100010111110101191001110011111100BCD码又可分为压缩式和非压缩式两类。非压缩式一般是一个字节来表示，其中高四位置0，低四位表示相应数字；压缩式仅采用四位表示相应的数字。示例代码以下代码基于压缩式8421码。[src]str2bcd.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* 十进制转成BCD码(单字节). 一个字节最多保存2位十进制数, 所以需要确保十进制数小于或等于99. */uint8_t hex2bcd(const uint8_t &amp;src)&#123; uint8_t temp; /* 高4位保存十进制数的十位, 低4位保存十进制数的个位. */ temp = (((src/10)&lt;&lt;4) + (src%10)); return temp;&#125;/* BCD码(单字节)转成十进制. */uint8_t bcd2hex(const uint8_t &amp;src)&#123; uint8_t temp; /* 高4位作为十进制数的十位, 低4位作为十进制数的个位. */ temp = ((src&gt;&gt;4)*10 + (src&amp;0x0f)); return temp;&#125;/* 十进制格式化字符串转成BCD码. */uint32_t str2bcd(const uint8_t *src, const uint32_t &amp;len, uint8_t *dst)&#123; uint8_t *ptr = dst; uint32_t cnt = len; /* 确保十进制格式化字符串的长度为偶数. */ if (cnt%2 != 0) &#123; *ptr++ = *src++ - '0'; --cnt; &#125; while (cnt) &#123; /* 每两个字节十进制拼接成一个字节BCD码. */ *ptr++ = ((*src++ - '0') &lt;&lt; 4) + (*src++ - '0'); --cnt; --cnt; &#125; *ptr = 0; /* 返回转换后的字符串长度. */ return ptr - dst;&#125;/* BCD码转成十进制格式化字符串. */uint32_t bcd2str(const uint8_t *src, const uint32_t &amp;len, uint8_t *dst)&#123; uint8_t *ptr = dst; uint32_t cnt = len; do &#123; /* 一个字节BCD码转换为两个字节十进制数. */ /* 处理高4位. */ *ptr++ = (*src &gt;&gt; 4) + '0'; /* 处理低4位. */ *ptr++ = (*src++ &amp; 0x0f) + '0'; &#125; while (--cnt); *ptr = 0; /* 返回转换后的字符串长度. */ return ptr - dst;&#125;","categories":[{"name":"编码方式","slug":"编码方式","permalink":"http://hanoi404.github.io/categories/编码方式/"}],"tags":[{"name":"编码方式","slug":"编码方式","permalink":"http://hanoi404.github.io/tags/编码方式/"},{"name":"BCD码","slug":"BCD码","permalink":"http://hanoi404.github.io/tags/BCD码/"}]},{"title":"Trimble GPS模块Android系统支持","slug":"trimble-gps-hal","date":"2018-10-10T02:56:35.000Z","updated":"2018-12-03T08:50:44.921Z","comments":true,"path":"552701786/","link":"","permalink":"http://hanoi404.github.io/552701786/","excerpt":"前言Trimble公司的BD930北斗GPS模块, 目前要做Android系统的标准接口支持(HAL层接口).","text":"前言Trimble公司的BD930北斗GPS模块, 目前要做Android系统的标准接口支持(HAL层接口).原来的做法分析原有的GPS模块是Broadcom的BCM4752, 先来看看与之相关的文件:init脚本[src]device/leadcore/fourmode/init.lc1860.rc12345678910...# gps chmod 0660 /dev/ttyS1 chown gps system /dev/ttyS1 # gps runs as gps + system permission, we need change the following files mode. mkdir /data/gps 0771 gps system chmod 0660 /sys/bus/platform/devices/brcm-gps.0/standby chown gps system /sys/bus/platform/devices/brcm-gps.0/standby chmod 0755 /system/bin/gps_config_init.sh...[src]device/leadcore/fourmode/init.lc1860.brcm.rc1234567891011121314151617...#for gps glconfig.xml check and copy on bootingservice gps_config_init /system/bin/gps_config_init.sh class main user root group system oneshot#gps daemonservice gps-daemon /system/bin/glgps -c /data/etc/glconfig.xml user gps class late_start socket gps seqpacket 0660 gps system socket rilgps.socket seqpacket 0660 gps system group system inet sdcard_rw...&#125;mk文件[src]device/leadcore/fourmode/brcm_config.mk123456789101112131415161718192021222324...GPS_COPY_PATH := hardware/broadcom/gpsPRODUCT_COPY_FILES += \\ $(GPS_COPY_PATH)/bcm4752/bin/glgps:system/bin/glgps \\ $(GPS_COPY_PATH)/bcm4752/bin/gpslogd:system/bin/gpslogd \\ $(GPS_COPY_PATH)/bcm4752/bin/gps.default.so:system/lib/hw/gps.default.so \\ $(GPS_COPY_PATH)/bcm4752/config/gps_config_init.sh:system/bin/gps_config_init.sh \\ frameworks/native/data/etc/android.hardware.location.gps.xml:system/etc/permissions/android.hardware.location.gps.xmlifeq ($(BUILD_MASS_PRODUCTION),true)PRODUCT_COPY_FILES += \\ $(GPS_COPY_PATH)/bcm4752/config/gps.conf:system/etc/gps.conf \\ $(GPS_COPY_PATH)/bcm4752/config/gps.conf:data/etc/gps.conf \\ $(GPS_COPY_PATH)/bcm4752/config/gpsconfig.xml:system/etc/glconfig.xml \\ $(GPS_COPY_PATH)/bcm4752/config/gpsconfig.xml:data/etc/glconfig.xml \\ $(GPS_COPY_PATH)/bcm4752/config/ca-cert-google.cer:system/etc/gps.pem elsePRODUCT_COPY_FILES += \\ $(GPS_COPY_PATH)/bcm4752/config/gps_CMCC.conf:system/etc/gps.conf \\ $(GPS_COPY_PATH)/bcm4752/config/gps_CMCC.conf:data/etc/gps.conf \\ $(GPS_COPY_PATH)/bcm4752/config/gpsconfig_CMCC.xml:system/etc/glconfig.xml \\ $(GPS_COPY_PATH)/bcm4752/config/gpsconfig_CMCC.xml:data/etc/glconfig.xml \\ $(GPS_COPY_PATH)/bcm4752/config/ca-cert-cmcc-commercial.cer:system/etc/gps.pem endif...小结从以上部分内容可以得出原有做法: 创建一个守护进程(glgps), 从串口(ttyS1)读取GPS数据, 然后使用localsocket进行进程间通信, 将GPS数据传输到HAL层.HAL的实现我尝试过还原Broadcom做法, HAL层基本没有问题(基于gps_qemu.c进行修改), 苦于没有守护进程(glgps)的源码, 自己摸索了一个简单的守护进程, 发现跑着中途会死掉. 后来想想还是先做简单点吧, 直接在HAL层打开串口读取数据, 再解析上报系统就好了.回调函数接口定义[src]hardware/libhardware/include/hardware/gps.h1234567891011121314/** GPS callback structure. */typedef struct &#123; /** set to sizeof(GpsCallbacks) */ size_t size; gps_location_callback location_cb; gps_status_callback status_cb; gps_sv_status_callback sv_status_cb; gps_nmea_callback nmea_cb; gps_set_capabilities set_capabilities_cb; gps_acquire_wakelock acquire_wakelock_cb; gps_release_wakelock release_wakelock_cb; gps_create_thread create_thread_cb; gps_request_utc_time request_utc_time_cb;&#125; GpsCallbacks;其中常用的接口为:location_cb上报GPS模块输出的定位信息.status_cb上报GPS模块自身状态和定位状态信息.sv_status_cb上报GPS模块输出的卫星信息.nmea_cb上报GPS模块输出的NMEA报文.create_thread_cb创建一个线程处理控制GPS模块命令和解析NMEA数据.JNI层调用函数接口定义JNI层调用HAL层的这些接口函数操作GPS硬件:[src]hardware/libhardware/include/hardware/gps.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** Represents the standard GPS interface. */typedef struct &#123; /** set to sizeof(GpsInterface) */ size_t size; /** * Opens the interface and provides the callback routines * to the implemenation of this interface. */ int (*init)( GpsCallbacks* callbacks ); /** Starts navigating. */ int (*start)( void ); /** Stops navigating. */ int (*stop)( void ); /** Closes the interface. */ void (*cleanup)( void ); /** Injects the current time. */ int (*inject_time)(GpsUtcTime time, int64_t timeReference, int uncertainty); /** Injects current location from another location provider * (typically cell ID). * latitude and longitude are measured in degrees * expected accuracy is measured in meters */ int (*inject_location)(double latitude, double longitude, float accuracy); /** * Specifies that the next call to start will not use the * information defined in the flags. GPS_DELETE_ALL is passed for * a cold start. */ void (*delete_aiding_data)(GpsAidingData flags); /** * min_interval represents the time between fixes in milliseconds. * preferred_accuracy represents the requested fix accuracy in meters. * preferred_time represents the requested time to first fix in milliseconds. */ int (*set_position_mode)(GpsPositionMode mode, GpsPositionRecurrence recurrence, uint32_t min_interval, uint32_t preferred_accuracy, uint32_t preferred_time); /** Get a pointer to extension information. */ const void* (*get_extension)(const char* name);&#125; GpsInterface;其中常用的接口为:init系统中开启GPS功能时调用, 进行初始化, 开启线程等待回调函数. 保存JNI调用时传递过来的回调函数, 打开GPS串口, 创建一对无名套接字,cleanup系统中关闭GPS功能时调用, 回收初始化的资源.startAPP中使用GPS功能时调用, 打开GPS模块电源, 设置回调函数.stopAPP中结束GPS功能时调用, 关闭GPS模块电源, 清空回调函数.主要流程分析系统启动时将LocationManagerService服务添加进系统服务中, LocationManagerService服务创建一个GpsLocationProvider对象, GpsLocationProvider对象初始化时获得GPS`HAL层控制接口, 然后注册一个Handler接收处理控制消息, 调用对应的GPSHAL`层控制接口.初始化服务LocationManagerService服务最终创建GpsLocationProvider对象, 然后检查GPS是否可用:[src]frameworks/base/services/java/com/android/server/LocationManagerService.java1234567891011121314private void loadProvidersLocked() &#123; ... // Create a gps location provider GpsLocationProvider gpsProvider = new GpsLocationProvider(mContext, this, mLocationHandler.getLooper()); if (GpsLocationProvider.isSupported()) &#123; mGpsStatusProvider = gpsProvider.getGpsStatusProvider(); mNetInitiatedListener = gpsProvider.getNetInitiatedListener(); addProviderLocked(gpsProvider); mRealProviders.put(LocationManager.GPS_PROVIDER, gpsProvider); &#125; ...&#125;加载模块在启动LocationManagerService时, 创建了一个GpsLocationProvider对象, 在GpsLocationProvider类中静态初始化块中调用:[src]frameworks/base/services/java/com/android/server/location/GpsLocationProvider.java12345public class GpsLocationProvider implements LocationProviderInterface &#123; ... static &#123; class_init_native(); &#125; ...&#125;其对应的JNI方法为android_location_GpsLocationProvider_class_init_native, 在该方法中, 根据GPS_HARDWARE_MODULE_ID加载/system/lib/hw/gps.default.so模块, 调用gps.default.so模块的open函数得到gps.default.so模块已实现的接口(GpsInterface):[src]frameworks/base/services/jni/com_android_server_location_GpsLocationProvider.cpp12345678910111213static void android_location_GpsLocationProvider_class_init_native(JNIEnv* env, jclass clazz) &#123; ... err = hw_get_module(GPS_HARDWARE_MODULE_ID, (hw_module_t const**)&amp;module); if (err == 0) &#123; hw_device_t* device; err = module-&gt;methods-&gt;open(module, GPS_HARDWARE_MODULE_ID, &amp;device); if (err == 0) &#123; gps_device_t* gps_device = (gps_device_t *)device; sGpsInterface = gps_device-&gt;get_gps_interface(gps_device); &#125; &#125; ...&#125;控制HAL接口在GpsLocationProvider类中, 注册了一个Handler接收控制消息, 处理消息内容, 调用对应的HAL层控制接口:[src]frameworks/base/services/java/com/android/server/location/GpsLocationProvider.java123456789101112131415161718192021222324252627282930313233343536373839404142434445private final class ProviderHandler extends Handler &#123; ... @Override public void handleMessage(Message msg) &#123; int message = msg.what; switch (message) &#123; case ENABLE: if (msg.arg1 == 1) &#123; handleEnable(); &#125; else &#123; handleDisable(); &#125; break; case SET_REQUEST: GpsRequest gpsRequest = (GpsRequest) msg.obj; handleSetRequest(gpsRequest.request, gpsRequest.source); break; case UPDATE_NETWORK_STATE: handleUpdateNetworkState(msg.arg1, (NetworkInfo)msg.obj); break; case INJECT_NTP_TIME: handleInjectNtpTime(); break; case DOWNLOAD_XTRA_DATA: if (mSupportsXtra) &#123; handleDownloadXtraData(); &#125; break; case INJECT_NTP_TIME_FINISHED: mInjectNtpTimePending = STATE_IDLE; break; case DOWNLOAD_XTRA_DATA_FINISHED: mDownloadXtraDataPending = STATE_IDLE; break; case UPDATE_LOCATION: handleUpdateLocation((Location)msg.obj); break; &#125; if (msg.arg2 == 1) &#123; // wakelock was taken for this message, release it mWakeLock.release(); &#125; &#125; ...&#125;;在系统设置中打开GPS, 最终调用到ENABLE中的handleEnable方法, 在该方法中调用native_init方法:[src]frameworks/base/services/java/com/android/server/location/GpsLocationProvider.java12345private void handleEnable() &#123; ... boolean enabled = native_init(); ...&#125;其对应的JNI方法为android_location_GpsLocationProvider_init, 在该方法中, 调用HAL层已实现的init接口:[src]frameworks/base/services/jni/com_android_server_location_GpsLocationProvider.cpp12345678static jboolean android_location_GpsLocationProvider_init(JNIEnv* env, jobject obj)&#123; ... // fail if the main interface fails to initialize if (!sGpsInterface || sGpsInterface-&gt;init(&amp;sGpsCallbacks) != 0) return false; ...&#125;HAL接口定义[src]gps_trimble.c123456789101112static const GpsInterface qemuGpsInterface = &#123; sizeof(GpsInterface), qemu_gps_init, qemu_gps_start, qemu_gps_stop, qemu_gps_cleanup, qemu_gps_inject_time, qemu_gps_inject_location, qemu_gps_delete_aiding_data, qemu_gps_set_position_mode, qemu_gps_get_extension,&#125;;HAL层初始化在qemu_gps_init接口中完成打开GPS串口的操作, 创建一对匿名套接字, 实现start和stop接口与主线程之间的通信, 达到控制解析NMEA数据的目的;[src]gps_trimble.c12345678910111213141516171819static voidgps_state_init(GpsState* state, GpsCallbacks* callbacks)&#123; ... // 打开GPS串口. state-&gt;fd = serial_init(); ... // 创建一对匿名套接字. if(socketpair(AF_LOCAL, SOCK_STREAM, 0, state-&gt;control) &lt; 0)&#123; ALOGE(\"could not create thread control socket pair: %s\", strerror(errno)); goto Fail; &#125; // 开启主线程. state-&gt;thread = callbacks-&gt;create_thread_cb(\"gps_state_thread\", gps_state_thread, state); ...&#125;这时, GPS服务已经完成了初始化工作, 等待APP使用定位.未完待续最近比较忙, 等忙完后继续更新, 先把源码上传…源码GitHub测试平台Android 4.4","categories":[{"name":"HAL","slug":"HAL","permalink":"http://hanoi404.github.io/categories/HAL/"}],"tags":[{"name":"HAL","slug":"HAL","permalink":"http://hanoi404.github.io/tags/HAL/"},{"name":"C/C++","slug":"C-C","permalink":"http://hanoi404.github.io/tags/C-C/"},{"name":"Android","slug":"Android","permalink":"http://hanoi404.github.io/tags/Android/"}]},{"title":"NTRIP通信协议之NTRIPCaster","slug":"ntripcaster","date":"2018-09-12T03:57:53.000Z","updated":"2018-09-26T07:27:23.601Z","comments":true,"path":"3453995741/","link":"","permalink":"http://hanoi404.github.io/3453995741/","excerpt":"前言NTRIP(Networked Transport of RTCM via Internet Protocol)是一种基于HTTP协议的数据传输协议, 在互联网上进行RTK(Real Time Kinematic)(实时动态载波相位差分技术)数据(NCT, RTCM, CMR, CMR+等等)传输的协议. NTRIP协议主要由NTRIPClient, NTRIPCaster, NTRIPServer三个部分组成. 这里搭建一个简单的NTRIPCaster.","text":"前言NTRIP(Networked Transport of RTCM via Internet Protocol)是一种基于HTTP协议的数据传输协议, 在互联网上进行RTK(Real Time Kinematic)(实时动态载波相位差分技术)数据(NCT, RTCM, CMR, CMR+等等)传输的协议. NTRIP协议主要由NTRIPClient, NTRIPCaster, NTRIPServer三个部分组成. 这里搭建一个简单的NTRIPCaster.NTRIPCaster功能NTRIPCaster主要实现以下几个功能:NTRIPServer连接NTRIPServer端请求连接NTRIPCaster时, NTRIPCaster检查是否存在请求的挂载点, 如果挂载点不存在, 则创建一个新的挂载点, 将其加入到挂载点链表; NTRIPServer端断开连接时, 将挂载点从挂载点链表移除;NTRIPClient连接NtripClient端请求获得RTK数据, NTRIPCaster解析NTRIPClient发送的请求数据, 检查挂载点, 检查用户名和密码, 确认无误后, 将NTRIPClient端的socket保存到挂载点节点中, 随后NTRIPServer发送RTK数据后进行转发; NTRIPClient端断开连接时, 将socket从挂载点节点中移除;返回源列表信息NTRIPClient端请求获得源列表时, NTRIPCaster从文件中读取挂载点详细信息, 按照NTRIP协议进行封装, 发送回NTRIPClient端;转发RTK数据NTRIPClient端已经存在于NTRIPServer端挂载点节点, 且已发送GPGGA数据时, NTRIPCaster将转发NTRIPServer端发送的RTK数据到已连接上的NTRIPClient端;处理GGA数据如果NTRIPCaster作为基准站, NTRIPClient端要发送一个位置坐标(GPGGA数据)到NTRIPCaster, NTRIPCaster使用该坐标作为基准站坐标, 允许将RTK数据发送到NTRIPClient端;NTRIPCaster实现主要流程设计NTRIPCaster使用epoll模型来实现高并发网络编程, 创建一个epoll对象, 然后创建一个TCP服务器(TCP Server), 添加进epoll对象的监听列表, 等待客户端的连接;客户端连接NTRIPCaster时, NTRIPCaster调用accept函数生成一个新的socket, 并将其添加进epoll对象的监听列表;客户端连接向NTRIPCaster发送数据时, NTRIPCaster接受并解析数据, 确认数据是NtripClient或NTRIPServer发过来的及数据的内容, 然后作出相应处理;客户端断开连接时, NTRIPCaster确认是NtripClient或NTRIPServer断开连接, 然后作出相应处理;核心代码主体运行部分:[src]ntripcaster.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void ntrip_caster::run(int time_out)&#123; ... for(int i = 0; i &lt; ret; i++)&#123; /* 监听到作为服务器的socket有事件发生. */ if(m_epoll_events[i].data.fd == m_listen_sock)&#123; /* EPOLLIN 事件说明有新的客户端请求连接, 向监听列表中添加该socket. */ if(m_epoll_events[i].events &amp; EPOLLIN)&#123; int new_sock = accept_new_client(); &#125; &#125;else&#123; /* EPOLLIN事件说明客户端已经发送数据, 需要接收数据并进行解析. */ if(m_epoll_events[i].events &amp; EPOLLIN)&#123; int recv_count = recv_data(m_epoll_events[i].data.fd, recv_buf); /* 接收到的数据长度为0, 客户端出错或者连接关闭, 从监听列表中移除该socket. */ if(recv_count == 0)&#123; int sock = m_epoll_events[i].data.fd; /* 如果是NTRIPClient端socket, 从挂载点节点中移除此socket. */ struct mnt_info *mi_ptr = check_conn(sock); if(mi_ptr &amp;&amp; mi_ptr-&gt;current_conn_cursor != -1)&#123; del_conn(mi_ptr); &#125; /* 如果是NTRIPServer端socket, 移除挂载点. */ mi_ptr = check_mntpoint(sock, NULL); if(mi_ptr)&#123; del_mntpoint(mi_ptr); &#125; /* 从监听列表中移除该socket. */ if(!epoll_ctl(m_epoll_fd, EPOLL_CTL_DEL, sock, &amp;m_epoll_events[i]))&#123; close(sock); &#125; continue; &#125; memcpy(send_buf, recv_buf, recv_count); /* 进行数据解析. */ parse_data(m_epoll_events[i].data.fd, recv_buf, recv_count); memset(recv_buf, 0, strlen(recv_buf)); &#125;else if(m_epoll_events[i].events &amp; EPOLLOUT)&#123; int send_count = send_data(m_epoll_events[i].data.fd, send_buf, strlen(send_buf)); memset(send_buf, 0, send_count); &#125; &#125; &#125; ...&#125;数据解析部分:[src]caster.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117int ntrip_caster::parse_data(int sock, char* recv_data, int data_len)&#123; ... /* 逐行解析数据. */ result = strtok(temp, \"\\n\"); if(result != NULL) &#123; /* NTRIPServer请求连接Caster. */ if(!strncasecmp(result, \"POST /\", 6) &amp;&amp; strstr(result, \"HTTP/1.1\"))&#123; sscanf(result, \"%*[^/]%*c%[^ ]\", m_mnt); /* 检查挂载点是否已经存在. */ struct mnt_info *mi_ptr = check_mntpoint(-1, m_mnt); if(mi_ptr != NULL)&#123; cout &lt;&lt; \"MountPoint already used!!!\" &lt;&lt; endl; /* 向NTRIPServer返回错误信息. */ send_data(sock, \"ERROR - Bad Password\\r\\n\", 22); return -1; &#125; result = strtok(NULL, \"\\n\"); while(result != NULL) &#123; if(!strncasecmp(result, \"Authorization: Basic\", 20))&#123; sscanf(result, \"%*[^ ]%*c%*[^ ]%*c%[^\\r]\", m_userpwd); if(strlen(m_userpwd) &gt; 0 )&#123; /* 解码挂载点用户名和密码. */ base64_decode(m_userpwd, m_username, m_password); /* 向挂载点链表添加挂载点. */ add_mntpoint(sock, m_mnt, m_username, m_password); /* 向NTRIPServer返回正确信息, NTRIPServer收到该信息后开始向NTRIPCaster发送RTK数据. */ send_data(sock, \"ICY 200 OK\\r\\n\", 12); return 0; &#125; &#125; result = strtok(NULL, \"\\n\"); &#125; &#125; /* 检测当前socket是否为已存在的挂载点(NTRIPServer), 若是则说明该数据为RTK数据, 需要转发给连接上此挂载点的NTRIPClient. */ if(struct mnt_info *mi_ptr = check_mntpoint(sock, NULL))&#123; if(mi_ptr != NULL)&#123; for(int i = 0; i &lt; mi_ptr-&gt;current_conn_count; ++i)&#123; if((mi_ptr-&gt;conn_sock[i] &gt; 0) &amp;&amp; (mi_ptr-&gt;send_flags&amp;(0x1&lt;&lt;i))) send_data(mi_ptr-&gt;conn_sock[i], recv_data, data_len); &#125; &#125; return 0; &#125; /* NTRIPClient请求获得源列表和请求连接挂载点(NTRIPServer)获取RTK数据. */ if(!strncasecmp(result, \"GET /\", 5) &amp;&amp; strstr(result, \"HTTP/1.1\"))&#123; sscanf(result, \"%*[^/]%*c%[^ ]\", m_mnt); /* 挂载点为空, NTRIPClient请求获得源列表. */ if(!strlen( m_mnt))&#123; char *st_data = new char[MAX_LEN]; /* 从文件中读取源列表信息, 将数据返回NTRIPClient. */ get_sourcetable(st_data, MAX_LEN); send_data(sock, st_data, strlen(st_data)); return 0; &#125; /* 挂载点不为空, NTRIPClient请求连接挂载点(NTRIPServer)获取RTK数据. */ /* 先检查挂载点是否存在. */ struct mnt_info *mi_ptr = check_mntpoint(-1, m_mnt); if(mi_ptr == NULL)&#123; cout &lt;&lt; \"MountPoint not find!!!\" &lt;&lt; endl; /* 向NTRIPClient返回错误信息. */ send_data(sock, \"HTTP/1.1 401 Unauthorized\\r\\n\", 27); return -1; &#125; result = strtok(NULL, \"\\n\"); while(result != NULL) &#123; if(!strncasecmp(result, \"Authorization: Basic\", 20))&#123; sscanf(result, \"%*[^ ]%*c%*[^ ]%*c%[^\\r]\", m_userpwd); if(strlen(m_userpwd) &gt; 0 )&#123; /* 解码用户名和密码. */ base64_decode(m_userpwd, m_username, m_password); /* 检验用户名和密码是否一致. */ if(strncmp(mi_ptr-&gt;username, m_username, strlen(m_username)) || strncmp(mi_ptr-&gt;password, m_password, strlen(m_password)))&#123; cout &lt;&lt; \"Password error!!!\" &lt;&lt; endl; /* 向NTRIPClient返回错误信息. */ send_data(sock, \"HTTP/1.1 401 Unauthorized\\r\\n\", 27); return -1; &#125; /* 将该socket保存到已找到的挂载点节点中. */ add_conn(mi_ptr, sock); /* 向NTRIPClient返回正确信息. */ send_data(sock, \"ICY 200 OK\\r\\n\", 12); return 0; &#125; &#125; result = strtok(NULL, \"\\n\"); &#125; &#125; /* NTRIPCaster作为基准站, NTRIPClient发送一个位置坐标(GPGGA)数据, NTRIPCaster以此坐标作为基准站坐标, 然后开始设置发送RTK数据标志. */ if(!strncasecmp(result, \"$GPGGA,\", 7))&#123; if(!check_sum(result))&#123; cout &lt;&lt; \"Check sum pass\" &lt;&lt; endl; /* RTK数据处理部分不做, 只做转发数据. */ /* 配置转发NtripServer的RTK数据. */ struct mnt_info *mi_ptr = check_conn(sock); if(mi_ptr &amp;&amp; mi_ptr-&gt;current_conn_cursor != -1)&#123; mi_ptr-&gt;send_flags |= 0x1 &lt;&lt; mi_ptr-&gt;current_conn_cursor; cout &lt;&lt; \"Start forward the server's data\" &lt;&lt; endl; &#125; return 0; &#125; &#125; &#125; ...&#125;NTRIP协议字符串示例1234567891011121314151617181920212223242526272829303132333435/* NTRIPServer请求连接创建挂载点. */\"POST /RTCM32 HTTP/1.1\\r\\nHost: 192.168.2.246:12345\\r\\nNtrip-Version: Ntrip/2.0\\r\\nUser-Agent: NTRIP TheXiiNTRIPServer/20180926\\r\\nAuthorization: Basic dGVzdDAxOnRlc3Rpbmc=\\r\\nNtrip-STR: \\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\"/* NTRIPCient请求获得源列表. */\"GET / HTTP/1.1\\r\\n\"/* NTRIPCient请求连接挂载点获取RTK数据. */\"GET /RTCM32 HTTP/1.1\\r\\nUser-Agent: NTRIP TheXiiNTRIPClient/20180926\\r\\nAccept: */*\\r\\nConnection: close\\r\\nAuthorization: Basic dGVzdDAxOnRlc3Rpbmc=\\r\\n\"/* NTRIPCient发送GPGGA数据. */\"$GPGGA,083552.00,3000.0000000,N,11900.0000000,E,1,08,1.0,0.000,M,100.000,M,,*57\\r\\n\"/* NTRIPCaster返回源列表数据. */\"SOURCETABLE 200 OKServer: NTRIP TheXiiNTRIPCaster/20180926Content-Type: text/plainContent-Length: 425STR;RTCM23;RTCM23;RTCM 2.3;1(1),3(10),18(1),19(1);2;GPS;SGNET;CHN;31;121;1;1;SGCAN;None;B;N;0;;STR;CMR;CMR;CMR;CMR;2;GPS;SGNET;CHN;31;121;1;1;SGCAN;None;B;N;0;;STR;CMRP;CMRP;CMR+;CMR;2;GPS;SGNET;CHN;31;121;1;1;Trimble GPSNet;None;B;N;0;;STR;DGPS;DGPS;RTCM 2.1;RTCM 2.1;2;GPS;SGNET;CHN;31;121;1;1;SGCAN;None;B;N;0;;STR;RTCM3X;RTCM3X;RTCM 3.X;1004(1),1005/1007(5),PBS(10);2;GPS;SGNET;CHN;31;121;1;1;SGCAN;None;B;N;0;;ENDSOURCETABLE\"项目源码: Github参考文章Ntrip通讯协议1.0linux c/c++网络编程之—epoll 模型","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://hanoi404.github.io/categories/C-C/"}],"tags":[{"name":"NTRIPCaster","slug":"NTRIPCaster","permalink":"http://hanoi404.github.io/tags/NTRIPCaster/"},{"name":"Ntrip协议2.0","slug":"Ntrip协议2-0","permalink":"http://hanoi404.github.io/tags/Ntrip协议2-0/"},{"name":"网络编程","slug":"网络编程","permalink":"http://hanoi404.github.io/tags/网络编程/"}]},{"title":"Base64编码与解码","slug":"base64code","date":"2018-09-05T01:51:19.000Z","updated":"2019-02-05T14:25:18.622Z","comments":true,"path":"1443023263/","link":"","permalink":"http://hanoi404.github.io/1443023263/","excerpt":"简介Base64是一种基于64个可打印字符来表示二进制数据的表示方法. 网络信息传递时, 一些二进制资源往往需要转换为Base64编码进行传输, 以提高传输效率. 标准编码表一般为ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/这64个字符. 因为编码后的+/等字符, 标准的Base64并不适合直接放在URL里传输, 有一些Base64的变种, 它们将+/等符号转换为其他符号(如_-), 这样就能安全的在URL中传输了. 虽然编码后字符内容长度会增加大约1/3, 但是在一定程度上保证了一些不可打印字符在传输时的的信息完整性.","text":"简介Base64是一种基于64个可打印字符来表示二进制数据的表示方法. 网络信息传递时, 一些二进制资源往往需要转换为Base64编码进行传输, 以提高传输效率. 标准编码表一般为ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/这64个字符. 因为编码后的+/等字符, 标准的Base64并不适合直接放在URL里传输, 有一些Base64的变种, 它们将+/等符号转换为其他符号(如_-), 这样就能安全的在URL中传输了. 虽然编码后字符内容长度会增加大约1/3, 但是在一定程度上保证了一些不可打印字符在传输时的的信息完整性.转换规则进行Base64转换的时候, 将3个byte(3*8bit=24bit)的数据, 先后放入一个24bit的缓冲区中, 先来的byte占高位. 数据不足3byte的话, 于缓冲器中剩下的bit用0补足. 然后,每次取出6个bit(24/6=4), 因为2^6=64, 按照其值选择编码表中对应的字符作为编码后的输出, 不断进行,直到全部输入数据转换完成. 当原数据长度不是3byte的整数倍时, 如果最后剩下1个输入数据, 在编码结果后加2个“=”; 如果最后剩下2个输入数据, 编码结果后加1个“=”; 如果没有剩下任何数据, 就什么都不要加.C示例源码[src]base64code.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;const char base64code[64] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";/* 根据字符值返回对应编表中的位置. */int chr2index(char ch)&#123; int i; for(i=0; i&lt; strlen(base64code); ++i)&#123; if(ch == base64code[i]) return i; &#125;&#125;/* 根据位置返回对应编表中的字符值. */char index2chr(int index)&#123; return base64code[index];&#125;/* 编码函数. */int encode(char *src, char *result)&#123; char temp[3] = &#123;0&#125;; int i = 0, j = 0, count = 0; int len = strlen(src); if(len==0) return -1; /* 原数据长度不为3的整数倍时, 计算需要补'='个数. */ if(len%3 != 0)&#123; count = 3 - len%3; &#125; while(i&lt;len)&#123; /* 每次处理3个char. */ strncpy(temp, src+i, 3); /* 提取原数据第1个char高6bit, 根据编码表得到对应的编码后字符. */ result[j+0] = index2chr((temp[0]&amp;0xFC)&gt;&gt;2); /* 提取原数据第1个char低2bit和第2个char的高4bit, 根据编码表得到对应的编码后字符. */ result[j+1] = index2chr(((temp[0]&amp;0x3)&lt;&lt;4) | ((temp[1]&amp;0xF0)&gt;&gt;4)); /* 原数据剩余1个char. */ if(temp[1]==0) break; /* 提取第2个char低4bit和第3个char的高2bit, 根据编码表得到对应的编码后字符. */ result[j+2] = index2chr(((temp[1]&amp;0xF)&lt;&lt;2) | ((temp[2]&amp;0xC0)&gt;&gt;6)); /* 原数据剩余2个char. */ if(temp[2]==0) break; /* 提取第3个char低6bit, 根据编码表得到对应字符. */ result[j+3] = index2chr(temp[2]&amp;0x3F); i+=3; j+=4; memset(temp, 0x0, 3); &#125; /* 补'='. */ while(count)&#123; result[j+4-count] = '='; --count; &#125; return 0;&#125;/* 解码函数. */int decode(char *src, char *result)&#123; char temp[4] = &#123;0&#125;; int i = 0, j = 0; int len = strlen(src); if(len==0 || len%4!=0) return 0; while(i&lt;len)&#123; /* 每次处理4个char. */ strncpy(temp, src+i, 4); /* 原数据每个char在编码表中对应的索引值的有效位为低6bit. */ /* 取原数据第1个char 根据编码表得到索引值, 将索引值有效位直接作为新char的高6bit, * 再取原数据第2个char, 根据编码表得到索引值, 将索引值有效位的高2bit作为新char的低2bit. */ result[j+0] = ((chr2index(temp[0])&amp;0x3F) &lt;&lt; 2) | ((chr2index(temp[1])&amp;0x3F) &gt;&gt; 4); /* 原数据出现'=', 说明后面内容无意义. */ if(temp[2] == '=') break; /* 取原数据第2个char, 根据编码表得到索引值, 将索引值有效位的低4bit作为新char的高6bit, * 再取原数据第3个char, 根据编码表得到索引值, 将索引值有效位的前4bit作为新char的低2bit. */ result[j+1] = ((chr2index(temp[1])&amp;0xF) &lt;&lt; 4) | ((chr2index(temp[2])&amp;0x3F) &gt;&gt; 2); /* 原数据出现'=', 说明后面内容无意义. */ if(temp[3] == '=') break; /* 取原数据第3个char, 根据编码表得到索引值, 将索引值有效位的低2bit作为新char的高2bit, * 再取原数据第4个char, 根据编码表得到索引值, 将索引值有效位直接作为新char的低6bit. */ result[j+2] = ((chr2index(temp[2])&amp;0x3) &lt;&lt; 6) | ((chr2index(temp[3])&amp;0x3F)); i+=4; j+=3; memset(temp, 0x0, 4); &#125; return 0;&#125;int main(void)&#123; char userpwd[32] = &#123;\"username:passwd\"&#125;; char result1[64] = &#123;0&#125;; char result2[64] = &#123;0&#125;; printf(\"source data: [%s]\\n\", userpwd); encode(userpwd, result1); printf(\"encode result: [%s]\\n\", result1); decode(result1, result2); printf(\"decode result: [%s]\\n\", result2); return 0;&#125;","categories":[{"name":"编码方式","slug":"编码方式","permalink":"http://hanoi404.github.io/categories/编码方式/"}],"tags":[{"name":"Base64","slug":"Base64","permalink":"http://hanoi404.github.io/tags/Base64/"},{"name":"编码方式","slug":"编码方式","permalink":"http://hanoi404.github.io/tags/编码方式/"}]},{"title":"Arm Linux下使用ldd","slug":"arm-ldd","date":"2018-08-21T04:16:24.000Z","updated":"2018-08-21T04:45:47.069Z","comments":true,"path":"3476998492/","link":"","permalink":"http://hanoi404.github.io/3476998492/","excerpt":"前言ldd命令用于打印程序或者库文件所依赖的共享库列表, ldd不是一个可执行程序, 而只是一个shell脚本. ldd显示可执行模块的依赖的工作原理, 其实质是通过ld-linux.so(动态库链接器)来实现的. ldd能够显示可执行模块的依赖, 其原理是通过设置一些的环境变量, 如LD_TRACE_LOADED_OBJECTS, LD_WARN, LD_BIND_NOW, LD_LIBRARY_VERSION, LD_VERBOSE等. 当LD_TRACE_LOADED_OBJECTS环境变量不为空时, 任何可执行程序在运行时, 它都会只显示模块的依赖, 而程序并不真正执行. 实际上可以直接执行ld-linux.so模块, 如: /lib/ld-linux.so.2 --list ls(这条命令相当于ldd ls).","text":"前言ldd命令用于打印程序或者库文件所依赖的共享库列表, ldd不是一个可执行程序, 而只是一个shell脚本. ldd显示可执行模块的依赖的工作原理, 其实质是通过ld-linux.so(动态库链接器)来实现的. ldd能够显示可执行模块的依赖, 其原理是通过设置一些的环境变量, 如LD_TRACE_LOADED_OBJECTS, LD_WARN, LD_BIND_NOW, LD_LIBRARY_VERSION, LD_VERBOSE等. 当LD_TRACE_LOADED_OBJECTS环境变量不为空时, 任何可执行程序在运行时, 它都会只显示模块的依赖, 而程序并不真正执行. 实际上可以直接执行ld-linux.so模块, 如: /lib/ld-linux.so.2 --list ls(这条命令相当于ldd ls).ubuntu下的lddubuntu下的ldd位于/usr/bin/ldd, 文件内容如下:[src]/usr/bin/ldd123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#! /bin/bash# Copyright (C) 1996-2016 Free Software Foundation, Inc.# This file is part of the GNU C Library.# The GNU C Library is free software; you can redistribute it and/or# modify it under the terms of the GNU Lesser General Public# License as published by the Free Software Foundation; either# version 2.1 of the License, or (at your option) any later version.# The GNU C Library is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU# Lesser General Public License for more details.# You should have received a copy of the GNU Lesser General Public# License along with the GNU C Library; if not, see# &lt;http://www.gnu.org/licenses/&gt;.# This is the `ldd' command, which lists what shared libraries are# used by given dynamically-linked executables. It works by invoking the# run-time dynamic linker as a command and setting the environment# variable LD_TRACE_LOADED_OBJECTS to a non-empty value.# We should be able to find the translation right at the beginning.TEXTDOMAIN=libcTEXTDOMAINDIR=/usr/share/localeRTLDLIST=\"/lib/ld-linux.so.2 /lib64/ld-linux-x86-64.so.2 /libx32/ld-linux-x32.so.2\"warn=bind_now=verbose=while test $# -gt 0; do case \"$1\" in --vers | --versi | --versio | --version) echo 'ldd (Ubuntu GLIBC 2.23-0ubuntu10) 2.23' printf $\"Copyright (C) %s Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\" \"2016\" printf $\"Written by %s and %s.\" \"Roland McGrath\" \"Ulrich Drepper\" exit 0 ;; --h | --he | --hel | --help) echo $\"Usage: ldd [OPTION]... FILE... --help print this help and exit --version print version information and exit -d, --data-relocs process data relocations -r, --function-relocs process data and function relocations -u, --unused print unused direct dependencies -v, --verbose print all information\" printf $\"For bug reporting instructions, please see:\\\\n%s.\\\\n\" \\ \"&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;\" exit 0 ;; -d | --d | --da | --dat | --data | --data- | --data-r | --data-re | \\ --data-rel | --data-relo | --data-reloc | --data-relocs) warn=yes shift ;; -r | --f | --fu | --fun | --func | --funct | --functi | --functio | \\ --function | --function- | --function-r | --function-re | --function-rel | \\ --function-relo | --function-reloc | --function-relocs) warn=yes bind_now=yes shift ;; -v | --verb | --verbo | --verbos | --verbose) verbose=yes shift ;; -u | --u | --un | --unu | --unus | --unuse | --unused) unused=yes shift ;; --v | --ve | --ver) echo &gt;&amp;2 $\"ldd: option \\`$1' is ambiguous\" exit 1 ;; --) # Stop option processing. shift; break ;; -*) echo &gt;&amp;2 'ldd:' $\"unrecognized option\" \"\\`$1'\" echo &gt;&amp;2 $\"Try \\`ldd --help' for more information.\" exit 1 ;; *) break ;; esacdonenonelf ()&#123; # Maybe extra code for non-ELF binaries. return 1;&#125;add_env=\"LD_TRACE_LOADED_OBJECTS=1 LD_WARN=$warn LD_BIND_NOW=$bind_now\"add_env=\"$add_env LD_LIBRARY_VERSION=\\$verify_out\"add_env=\"$add_env LD_VERBOSE=$verbose\"if test \"$unused\" = yes; then add_env=\"$add_env LD_DEBUG=\\\"$LD_DEBUG$&#123;LD_DEBUG:+,&#125;unused\\\"\"fi# The following command substitution is needed to make ldd work in SELinux# environments where the RTLD might not have permission to write to the# terminal. The extra \"x\" character prevents the shell from trimming trailing# newlines from command substitution results. This function is defined as a# subshell compound list (using \"(...)\") to prevent parameter assignments from# affecting the calling shell execution environment.try_trace() ( output=$(eval $add_env '\"$@\"' 2&gt;&amp;1; rc=$?; printf 'x'; exit $rc) rc=$? printf '%s' \"$&#123;output%x&#125;\" return $rc)case $# in0) echo &gt;&amp;2 'ldd:' $\"missing file arguments\" echo &gt;&amp;2 $\"Try \\`ldd --help' for more information.\" exit 1 ;;1) single_file=t ;;*) single_file=f ;;esacresult=0for file do # We don't list the file name when there is only one. test $single_file = t || echo \"$&#123;file&#125;:\" case $file in */*) : ;; *) file=./$file ;; esac if test ! -e \"$file\"; then echo \"ldd: $&#123;file&#125;:\" $\"No such file or directory\" &gt;&amp;2 result=1 elif test ! -f \"$file\"; then echo \"ldd: $&#123;file&#125;:\" $\"not regular file\" &gt;&amp;2 result=1 elif test -r \"$file\"; then RTLD= ret=1 for rtld in $&#123;RTLDLIST&#125;; do if test -x $rtld; then dummy=`$rtld 2&gt;&amp;1` if test $? = 127; then verify_out=`$&#123;rtld&#125; --verify \"$file\"` ret=$? case $ret in [02]) RTLD=$&#123;rtld&#125;; break;; esac fi fi done case $ret in 0|2) try_trace \"$RTLD\" \"$file\" || result=1 ;; 1) # This can be a non-ELF binary or no binary at all. nonelf \"$file\" || &#123; echo $\" not a dynamic executable\" result=1 &#125; ;; *) echo 'ldd:' $&#123;RTLD&#125; $\"exited with unknown exit code\" \"($ret)\" &gt;&amp;2 exit 1 ;; esac else echo 'ldd:' $\"error: you do not have read permission for\" \"\\`$file'\" &gt;&amp;2 result=1 fidoneexit $result# Local Variables:# mode:ksh# End:在arm平台上使用因为ldd是一个脚本, 所以只需稍作修改就可以在arm平台执行. 首先替换脚本解释器, arm平台用的基本都是/bin/sh:[src]/bin/ldd12- #! /bin/bash+ #! /bin/sh然后替换动态库链接器, 我的交叉编译工具使用的是ld-linux-hf.so.3, 因此修改如下:[src]/bin/ldd12- RTLDLIST=\"/lib/ld-linux.so.2 /lib64/ld-linux-x86-64.so.2 /libx32/ld-linux-x32.so.2\"+ RTLDLIST=\"/lib/ld-linux-hf.so.3\"将修改好的ldd文件拷贝到开发板上/bin目录下, 测试:123456$ ldd --version ldd (GNU libc) 2.26Copyright (C) 2017 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.Written by Roland McGrath and Ulrich Drepper.测试通过.测试环境@系统: Windows 7 Professional with SP1@Vivado: 2015.04@虚拟机: OSRC_Miz7_ubuntu_14@开发板: 米联MIZ702N参考文章ldd命令","categories":[{"name":"Linux","slug":"Linux","permalink":"http://hanoi404.github.io/categories/Linux/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://hanoi404.github.io/tags/嵌入式/"},{"name":"Linux","slug":"Linux","permalink":"http://hanoi404.github.io/tags/Linux/"}]},{"title":"Linux下配置软AP分享Wifi热点","slug":"softap","date":"2018-08-20T04:39:51.000Z","updated":"2018-09-28T07:32:50.536Z","comments":true,"path":"1178631641/","link":"","permalink":"http://hanoi404.github.io/1178631641/","excerpt":"前言最近有个项目要求用无线网卡开启wifi热点, 由于板子目前还没回来, 那么先在Ubuntu下测试, 后面在进行移植. 我之前使用过Ubuntu自带的网络管理器和kde-nm-connection-editor(为了改mode从而使Android设备能识别, 后来发现其实可以直接改配置文件)成功搭建过wifi热点, 现在在ububtu14.04上试了很多次未成功(无法连接到隐藏网络), 后来一想最后要移植到开发板上, 应该是不用图形界面的, 还是老老实实用命令行配置吧. 使用命令行配置的话, 要用Hostapd创建一个无线接入点, 然后配置连接终端可以自动获取ip地址, 再共享以太网给无线网卡, 此时应该就可以正常上网了, 那么就开始吧.","text":"前言最近有个项目要求用无线网卡开启wifi热点, 由于板子目前还没回来, 那么先在Ubuntu下测试, 后面在进行移植. 我之前使用过Ubuntu自带的网络管理器和kde-nm-connection-editor(为了改mode从而使Android设备能识别, 后来发现其实可以直接改配置文件)成功搭建过wifi热点, 现在在ububtu14.04上试了很多次未成功(无法连接到隐藏网络), 后来一想最后要移植到开发板上, 应该是不用图形界面的, 还是老老实实用命令行配置吧. 使用命令行配置的话, 要用Hostapd创建一个无线接入点, 然后配置连接终端可以自动获取ip地址, 再共享以太网给无线网卡, 此时应该就可以正常上网了, 那么就开始吧.确认网卡是否支持master模式在命令行终端输入iw list命令:1$ sudo iw list如果Supported interface modes中有AP或AP/VLAN, 说明这张网卡支持master模式:123Supported interface modes: * AP * AP/VLAN配置hostapd编写/etc/hostapd/hostapd.conf文件, 输入以下内容:[src]/etc/hostapd/hostapd.conf12345678910111213interface=wlan0#bridge=br0driver=nl80211ssid=softapchannel=1hw_mode=gignore_broadcast_ssid=0auth_algs=1wpa=3wpa_passphrase=11111111wpa_key_mgmt=WPA-PSKwpa_pairwise=TKIPrsn_pairwise=CCMP接下来看看这些配置部分选项说明:12345678910interface: Atheros 接口始终名为 athx, 所有其他接口都是wlanx.bridge: 如果接入点没有以太网桥接, 可以省略bridge一行的内容.driver: 如果使用的是hostapd V0.6.8或其更高版本以及具有mac80211支持的WI, 那么驱动程序是nl80211. 惟一受支持的旧版驱动程序是HostAP,madwifi和prism54. V0.6.8之前的hostapd发行版支持hostap,wiredk,madwifi,test,nl80211和bsd驱动程序.ssid: 接入点名称.channel: 802.11b/g都最多只有三条互不干扰的信道, 即1,6,11, 选择其中一个就行.auth_algs：1表示只支持WPA2身份验证算法; 2表示只支持WEP; 3表示支持这两种方式. 永远不要使用有线等效加密(wired equivalent privacy, WEP), 因为它非常容易破解, 并且多年前就已经被完全破解了.wpa: 1表示支持WPA1; 2仅支持WPA2; 3表示二者都支持.wpa_passphrase: 接入点密码;wpa_key_mgmt: 支持的加密密钥算法. 选择有WPA-PSK,WPA-EAP或两者均使用. PSK是预共享密钥. EAP是可扩展认证协议, 是一个支持许多不同身份验证方法的框架, 对于小的预共享密钥设置, 不需要使用它.wpa_pairwise,rsn_pairwise: 控制支持加密数据的密钥, 您可以使用CCMP,TKIP或两者均使用. CCMP比TKIP更强, 因此建议仅支持CCMP.编写完成后, 在终端输入以下内容, 测试配置文件是否有问题:1$ hostadp /etc/hostapd/hostapd.conf这时, 你的手机可以搜索到该热点, 但由于无法获取到IP地址仍然无法连接.连接网络可以选择NAT或是网桥方式来使该AP的接入设备获得ip地址.NAT选择NAT方式的话, 要先为接入设备分配ip地址, 就能够连上热点, 但是无法连到网络. 通过配置NAT, 让终端发出的数据包的IP修改为公网IP, 即可连上网络. 首先为无线网卡分配IP地址并启用：1$ sudo ifconfig wlan0 192.168.3.1 netmask 255.255.255.0 up这里介绍两种自动获取IP服务配置:DHCP安装dhcp:1$ sudo apt-get install isc-dhcp-server打开/etc/dhcp/dhcpd.conf配置文件, 修改以下内容:[src]/etc/dhcp/dhcpd.conf12345subnet 192.168.3.0 netmask 255.255.255.0 &#123; range 192.168.3.20 192.168.3.200; option routers 192.168.3.1; option domain-name-servers 8.8.8.8;&#125;重启dhcp服务:1$ sudo service isc-dhcp-server restartDNSMASQ在命令行终端输入输入以下命令安装dnsmasq:1$ sudo apt-get install dnsmasq打开/etc/dnsmasq.conf配置文件, 添加以下内容:[src]/etc/dnsmasq.conf12345interface=wlan0listen-address=192.168.3.1#no-dhcp-interface=dhcp-range=192.168.3.20,192.168.3.200,12hserver=/google/8.8.8.8重启dnsmasq服务:1$ sudo service dnsmasq restart出现OK就成功了.配置NAT通过上面两种配置后, 手机可以连接上热点, 但还无法连接外网, 需要配置路由转发. 首先打开内核的ip转发功能:1$ sudo echo \"1\" &gt; /proc/sys/net/ipv4/ip_forward使用iptables设置转发:123$ sudo iptables -t nat -I POSTROUTING -o eth0 -j MASQUERADE $ sudo iptables -A FORWARD -s 192.168.3.0/24 -j ACCEPT$ sudo iptables -A FORWARD -d 192.168.3.0/24 -j ACCEPT不出意外, 此时手机应该可以连接上外网了.网桥选择的是网桥方式, 那么IP地址将会由电脑实际连接的外网分配, 并且连接的终端可以直接发送数据到外网. 热点连上了就可以直接用了, 且和计算机的有线端同处于一个子网. 首先创建一个虚拟的以太网桥接口:1$ sudo brctl addbr br0我们不需要STP(生成树协议)等. 因为我们只有一个路由器，是绝对不可能形成一个环的, 我们可以关闭这个功能.1$ sudo brctl stp br0 off添加以太网物理接口和无线网卡接口到网桥上:12$ sudo brctl addif br0 eth0$ sudo brctl addif br0 wlan0如果wlan0无法添加, 尝试以下命令:1$ sudo iw dev wlan0 set 4addr on配置网桥的IP和默认网关, 要和机器所在局域网同一网段:12$ sudo ifconfig br0 192.168.2.184 netmask 255.255.255.0 up$ sudo route add default gw 192.168.2.1以太网物理接口和无线网卡接口成为网桥设备的一部分了, 所以不再需要IP地址.下面我们将这些IP地址释放掉:1234$ sudo ifconfig eth0 down$ sudo ifconfig wlan0 down$ sudo ifconfig eth0 0.0.0.0 up$ sudo ifconfig wlan0 0.0.0.0 up启用网桥设备:1$ sudo ifconfig br0 up大功告成, 尽情享受吧!参考文章linux软AP－－hostapd+dhcpd使用 hostapd 轻松实现强 WiFi 加密","categories":[{"name":"Linux","slug":"Linux","permalink":"http://hanoi404.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://hanoi404.github.io/tags/Linux/"},{"name":"网络","slug":"网络","permalink":"http://hanoi404.github.io/tags/网络/"}]},{"title":"嵌入式LINUX下CGI与HTML网页之间的通信","slug":"cgi-html","date":"2018-08-15T07:04:34.000Z","updated":"2018-08-16T09:18:50.377Z","comments":true,"path":"1522571396/","link":"","permalink":"http://hanoi404.github.io/1522571396/","excerpt":"前言CGI 是Web服务器运行时外部程序的规范, 按CGI编写的程序可以扩展服务器功能. CGI应用程序能与浏览器进行交互, 还可通过数据库API与数据库服务器等外部数据源进行通信, 从数据库服务器中获取数据.几乎所有服务器都支持CGI,可用任何语言编写CGI,包括C/C++, Python, Shell等.本文通过编写一个简单的登录的用例来了解CGI与HTML如何互相传递参数. 要在CGI和HTML之间传递数据, 需要移植CGI库, 由于比较简单这里就不再赘述, 本文默认已经移植好了CGI库以及能在开发板上使用httpd服务搭建Web服务器.HTML调用CGI并传递参数在HTML中我们使用表单(from), 采集和提交用户输入信息, 然后调用CGI程序处理:","text":"前言CGI 是Web服务器运行时外部程序的规范, 按CGI编写的程序可以扩展服务器功能. CGI应用程序能与浏览器进行交互, 还可通过数据库API与数据库服务器等外部数据源进行通信, 从数据库服务器中获取数据.几乎所有服务器都支持CGI,可用任何语言编写CGI,包括C/C++, Python, Shell等.本文通过编写一个简单的登录的用例来了解CGI与HTML如何互相传递参数. 要在CGI和HTML之间传递数据, 需要移植CGI库, 由于比较简单这里就不再赘述, 本文默认已经移植好了CGI库以及能在开发板上使用httpd服务搭建Web服务器.HTML调用CGI并传递参数在HTML中我们使用表单(from), 采集和提交用户输入信息, 然后调用CGI程序处理:[src]www/index.html1234567...&lt;form action=\"/cgi-bin/getresult_cgi.cgi\" method=\"POST\"&gt; &lt;input type=\"text\" name=\"Username\" placeholder=\"User\" required=\"required\" /&gt; &lt;input type=\"password\" name=\"Password\" placeholder=\"Passwd\" required=\"required\" /&gt; &lt;button type=\"submit\"&gt; Login &lt;/button&gt;&lt;/form&gt;...Tipsaction为处理表单请求的程序;method表示发送表单信息的方式. method有两个值: GET和POST. GET是把参数数据队列加到提交表单的ACTION属性所指的URL中, 值和表单内各个字段一一对应, 在URL中可以看到; POST是通过HTTP POST机制, 将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址, 用户看不到这个过程. GET一般用于取得和显示数据; POST多用于数据的保存更新;我们来看看CGI程序中是如何接受传递的参数. 首先是获取请求方式, 根据请求方式去拿数据:[src]getresult_cgi.c1234567int main(void)&#123; ... req_method = getenv(\"REQUEST_METHOD\"); input = getcgidata(stdin, req_method); ...&#125;来看下解析数据关键代码:[src]getresult_cgi.c1234567891011121314151617char* getcgidata(FILE* fp, char* requestmethod)&#123; ... if (!strcmp(requestmethod, \"GET\")) &#123; input = getenv(\"QUERY_STRING\"); ... &#125; else if (!strcmp(requestmethod, \"POST\")) &#123; len = atoi(getenv(\"CONTENT_LENGTH\")); input = (char*)malloc(sizeof(char)*(size + 1)); ... while(1) &#123; input[i] = (char)fgetc(fp); ... &#125; &#125; ...&#125;可以看出GET请求传递的参数保存在环境变量QUERY_STRING中, 而POST请求将传递的参数保存在标准输入(stdin)中; 然后开始解析字符串:src:getresult_cgi.c123456int main(void)&#123; ... sscanf(input, \"%*[^=]=%[^&amp;]%*[^=]=%[^EOF]\", name, pass); ...&#125;这里使用sscanf来提取用户名和密码, 从HTML传递过来的参数格式应为:1Username=admin&amp;Password=aaaaasscanf中格式化字符串的含义为:12%*[^=]=%[^&amp;]: 读取‘=’和‘&amp;’之间的字符, 放到name中;%*[^=]=%[^EOF]: 读取‘=’到文件流结尾之前的字符, 放到pass中;至此, 已经将HTML传递过来的参数解析完毕;CGI返回数据给HTML本文要做的是根据用户名和密码正不正确来返回不同信息: 正确返回login success信息, 错误返回输入的用户名和密码. 要将CGI数据传给HTML, 可以在CGI程序中直接生成一个页面, 不过这样好像不够灵活, 那么就使用HTML页面跳转时用来传递数据的Cookie来实现CGI与HTML间数据的传递:[src]getresult_cgi.c12345678910111213int main(void) ... if (!strncmp(name, \"root\", 4) &amp;&amp; !strncmp(pass, \"000\", 3))&#123; printf(\"Set-Cookie: %s=%s; path=/\\r\\n\",\"Result\",\"login success\"); printf(\"%s%c%c\\n\",\"Content-Type:text/html;charset=utf-8\",13,10); printf(\"&lt;meta http-equiv=\\\"refresh\\\" content=\\\"0;url=../result.html\\\"&gt;\"); &#125; else &#123; printf(\"Set-Cookie: %s=%s&amp;&amp;%s; path=/\\r\\n\",\"Result\", name, pass); printf(\"%s%c%c\\n\",\"Content-Type:text/html;charset=utf-8\",13,10); printf(\"&lt;meta http-equiv=\\\"refresh\\\" content=\\\"0;url=../result.html\\\"&gt;\"); &#125; ...&#125;这里要注意的是要先设置Cookie后再输出http请求头, 否则Cookie无效. 接着我们看看HTML是怎么接受Cookie的:[src]www/result.html12345678910...&lt;form&gt; Login Result= &lt;input name=\"lignt_now\" type=\"text\" id=\"result_text\" /&gt;&lt;/form&gt;&lt;script type=\"text/javascript\" &gt; cookie_text= document.getElementById('result_text'); cookie_text.value =getCookie('Result')&lt;/script&gt;...这里使用了一个表单, 表单内有一个文本框, 内容由javascript来填充; 我们再来看看getCookie()做了什么:[src]www/result.html12345678910111213141516171819...&lt;script type=\"text/javascript\" &gt;function getCookie(c_name)&#123; if (document.cookie.length&gt;0) &#123; c_start=document.cookie.indexOf(c_name + \"=\") if (c_start!=-1) &#123; c_start=c_start + c_name.length+1 c_end=document.cookie.indexOf(\";\",c_start) if (c_end==-1) c_end=document.cookie.length return unescape(document.cookie.substring(c_start,c_end)) &#125; &#125; return \"\"&#125;&lt;/script&gt;...前面我们传递的Cookie为“Result=login success”或“Result=username, password”. 在javascript中根据首尾字符使用document.cookie.indexOf()来获取Cookie有效内容的开始和结束位置, 然后根据字符开始和结束位置使用document.cookie.substring()读取子字符串, 最终得到需要的数据.详细代码这里把所有代码都贴出来,首先是CGI程序:[src]getresult_cgi.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;string.h&gt;#include &lt;iconv.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include \"cgi.h\"#include \"aux.h\"char* getcgidata(FILE* fp, char* requestmethod)&#123; char* input; int len; int size = 1024; int i = 0; if (!strcmp(requestmethod, \"GET\")) &#123; input = getenv(\"QUERY_STRING\"); return input; &#125; else if (!strcmp(requestmethod, \"POST\")) &#123; len = atoi(getenv(\"CONTENT_LENGTH\")); input = (char*)malloc(sizeof(char)*(size + 1)); if (len == 0) &#123; input[0] = '\\0'; return input; &#125; while(1) &#123; input[i] = (char)fgetc(fp); if (i == size) &#123; input[i+1] = '\\0'; return input; &#125; --len; if (feof(fp) || (!(len))) &#123; i++; input[i] = '\\0'; return input; &#125; ++i; &#125; &#125; return NULL;&#125;int main(void)&#123; char *input; char *req_method; char name[32]; char pass[32]; req_method = getenv(\"REQUEST_METHOD\"); input = getcgidata(stdin, req_method); /* Format: Username=admin&amp;Password=aaaaa. */ //sscanf(input, \"%*[^=]=%*c%[^&amp;]%*[^=]%*c%[^\\n]\", name, pass); sscanf(input, \"%*[^=]=%[^&amp;]%*[^=]=%[^EOF]\", name, pass); if (!strncmp(name,\"root\",4) &amp;&amp; !strncmp(pass, \"000\", 3))&#123; /* Set Cookie. */ printf(\"Set-Cookie: %s=%s; path=/\\r\\n\",\"Result\",\"login success\"); printf(\"%s%c%c\\n\",\"Content-Type:text/html;charset=utf-8\",13,10); printf(\"&lt;meta http-equiv=\\\"refresh\\\" content=\\\"0;url=../result.html\\\"&gt;\"); &#125; else &#123; printf(\"Set-Cookie: %s=%s&amp;&amp;%s; path=/\\r\\n\",\"Result\", name, pass); printf(\"%s%c%c\\n\",\"Content-Type:text/html;charset=utf-8\",13,10); printf(\"&lt;meta http-equiv=\\\"refresh\\\" content=\\\"0;url=../result.html\\\"&gt;\"); &#125; return 0;&#125;主页index.html:[src]www/index.html12345678910111213&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt; Login &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/cgi-bin/getresult_cgi.cgi\" method=\"POST\"&gt; &lt;input type=\"text\" name=\"Username\" placeholder=\"User\" required=\"required\" /&gt; &lt;input type=\"password\" name=\"Password\" placeholder=\"Passwd\" required=\"required\" /&gt; &lt;button type=\"submit\"&gt; Login &lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;返回结果result.html:[src]www/result.html123456789101112131415161718192021222324252627282930313233&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;script type=\"text/javascript\" &gt;function getCookie(c_name)&#123; if (document.cookie.length&gt;0) &#123; c_start=document.cookie.indexOf(c_name + \"=\") if (c_start!=-1) &#123; c_start=c_start + c_name.length+1 c_end=document.cookie.indexOf(\";\",c_start) if (c_end==-1) c_end=document.cookie.length return unescape(document.cookie.substring(c_start,c_end)) &#125; &#125; return \"\"&#125;&lt;/script&gt;&lt;title&gt;Result&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; Login Result= &lt;input name=\"lignt_now\" type=\"text\" id=\"result_text\" /&gt;&lt;/form&gt;&lt;script type=\"text/javascript\" &gt; bang_text= document.getElementById('result_text'); bang_text.value =getCookie('Result')&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;参考文章嵌入式CGI 与HTML的数据交换CGI编程","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://hanoi404.github.io/categories/嵌入式/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://hanoi404.github.io/tags/嵌入式/"},{"name":"cgi","slug":"cgi","permalink":"http://hanoi404.github.io/tags/cgi/"},{"name":"html","slug":"html","permalink":"http://hanoi404.github.io/tags/html/"}]},{"title":"ZYNQ从BUSYBOX开始制作RAMDISK","slug":"zynq-ramdisk","date":"2018-08-13T10:14:25.000Z","updated":"2018-09-18T08:54:26.752Z","comments":true,"path":"2391800641/","link":"","permalink":"http://hanoi404.github.io/2391800641/","excerpt":"Busybox移植BusyBox将许多具有共性的小版本的UNIX工具结合到一个单一的可执行文件. 这样的集合可以替代大部分常用工具, BusyBox提供了一个比较完善的环境，可以适用于任何小的嵌入式系统.这篇文章将从移植Busybox开始, 一步一步制作一个属于自己的根文件系统.","text":"Busybox移植BusyBox将许多具有共性的小版本的UNIX工具结合到一个单一的可执行文件. 这样的集合可以替代大部分常用工具, BusyBox提供了一个比较完善的环境，可以适用于任何小的嵌入式系统.这篇文章将从移植Busybox开始, 一步一步制作一个属于自己的根文件系统.下载Busybox的官方源码下载路径为: 点我本次下载的是busybox-1.29.1.tar.bz2配置解压下载的文件, 进入到源码根目录:1$ tar xvf busybox-1.29.1.tar.bz2 &amp;&amp; cd busybox-1.29.1先使用默认配置:1$ make deconfig然后输入命令进行配置:1$ make menuconfig配置以下选项:1234Settings ---&gt; [ ] Don't use /usr [ ] Build static binary (no shared libs) (arm-linux-gnueabihf-) Cross compiler prefix第一个是选择是否编译出/usr相关目录, 这里不勾选则生成/usr目录;第二个是选择静态编译不依赖动态库, 制作根文件系统后面会拷贝一套动态连接库, 先不勾选;第三个是配置交叉编译工具, 根据实际情况填写;其他的需要的命令支持自行选择配置.Tips静态编译与动态编译的区别动态编译的可执行文件需要附带一个的动态链接库, 在执行时, 需要调用其对应动态链接库中的命令. 所以其优点一方面是缩小了执行文件本身的体积, 另一方面是加快了编译速度, 节省了系统资源. 缺点一是哪怕是很简单的程序, 只用到了链接库中的一两条命令, 也需要附带一个相对庞大的链接库; 二是如果其他计算机上没有安装对应的运行库, 则用动态编译的可执行文件就不能运行.静态编译就是编译器在编译可执行文件的时候, 将可执行文件需要调用的对应动态链接库(.so)中的部分提取出来, 链接到可执行文件中去, 使可执行文件在运行的时候不依赖于动态链接库. 所以其优缺点与动态编译的可执行文件正好互补.编译1$ make &amp;&amp; make install生成文件位于_install文件夹内:12$ ls _install/bin linuxrc sbin usr拷贝lib库新建一个root目录, 进入该目录下:1$ mkdir root &amp;&amp; cd root/将编译busybox生成的目录下的所有文件拷贝过去:1$ cp -af ../busybox-1.29.1/_install/* .创建其他的目录1$ mkdir dev etc lib sys proc tmp var home root mnt拷贝lib库整个lib库有很多, 全部拷贝的话就有点臃肿了, 下面是我参考官方的ramdisk里面的lib库拷贝的, 应该还可以再精简, 先凑合着用吧:1234567891011121314$ ls lib/ld-2.25.so libcidn-2.25.so libgfortran.so.4 libnss_compat-2.25.so libnss_nis.so.2 libstdc++.so.6ld-linux-armhf.so.3 libcidn.so.1 libgfortran.so.4.0.0 libnss_compat.so.2 libpcprofile.so libstdc++.so.6.0.24libanl-2.25.so libcilkrts.so libgomp.so libnss_db-2.25.so libpthread-2.25.so libstdc++.so.6.0.24-gdb.pylibanl.so.1 libcilkrts.so.5 libgomp.so.1 libnss_db.so.2 libpthread.so.0 libthread_db-1.0.solibasan.so libcilkrts.so.5.0.0 libgomp.so.1.0.0 libnss_dns-2.25.so libresolv-2.25.so libthread_db.so.1libasan.so.4 libcrypt-2.25.so libitm.so libnss_dns.so.2 libresolv.so.2 libubsan.solibasan.so.4.0.0 libcrypt.so.1 libitm.so.1 libnss_files-2.25.so librt-2.25.so libubsan.so.0libatomic.so libc.so.6 libitm.so.1.0.0 libnss_files.so.2 librt.so.1 libubsan.so.0.0.0libatomic.so.1 libdl-2.25.so libm-2.25.so libnss_hesiod-2.25.so libSegFault.so libutil-2.25.solibatomic.so.1.2.0 libdl.so.2 libmemusage.so libnss_hesiod.so.2 libssp.so libutil.so.1libBrokenLocale-2.25.so libgcc_s.so libm.so.6 libnss_nis-2.25.so libssp.so.0libBrokenLocale.so.1 libgcc_s.so.1 libnsl-2.25.so libnss_nisplus-2.25.so libssp.so.0.0.0libc-2.25.so libgfortran.so libnsl.so.1 libnss_nisplus.so.2 libstdc++.so接下来拷贝上面的运行库:1$ cp -af /opt/toolchain/arm-linux-gnueabihf/arm-linux-gnueabihf/libc/lib/*.so* lib/Tips各个交叉编译工具的运行库的所在位置可能不同;部分库文件是符号链接, 要保留原文件属性的前提下复制文件请使用 cp -a 命令;然后去掉库文件的符号表和调试信息进行瘦身, 进一步减少空间占用:1$ arm-linux-gnueabihf-strip lib/*现在整个可执行命令以及运行库已移植完成, 接下来是启动添加配置文件.启动配置文件profile文件新建etc/profile文件, 并添加以下内容:[src]etc/profile123456789#!/bin/shexport HOSTNAME=skycasterexport USER=rootexport HOME=homeexport PS1=\"[$USER@$HOSTNAME \\W]\\# \"PATH=/bin:/sbin:/usr/bin:/usr/sbinLD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATHexport PATH LD_LIBRARY_PATHinittab文件新建etc/inittab文件, 并添加以下内容:[src]etc/inittab123456789#this is run first except when booting in single-user mode. ::sysinit:/etc/init.d/rcS# /bin/sh invocations on selected ttys# start an &quot;askfirst&quot; shell on the console (whatever that may be)::askfirst:-/bin/sh# stuff to do when restarting the init process::restart:/sbin/init# stuff to do before rebooting::ctrlaltdel:/sbin/rebootfstab文件新建etc/fstab文件, 并添加以下内容:[src]etc/fstab12345LABEL=/ / tmpfs defaults 0 0none /dev/pts devpts gid=5,mode=620 0 0none /proc proc defaults 0 0none /sys sysfs defaults 0 0none /tmp tmpfs defaults 0 0rcS文件新建etc/init.d/rcS文件, 并添加以下内容:[src]etc/init.d/rcS12345678910111213141516171819#!/bin/shecho \"Starting rcS...\"echo \"++ Mounting filesystem\"mount -t proc none /procmount -t sysfs none /sysmount -t tmpfs none /tmpecho \"++ Setting up mdev\"echo /sbin/mdev &gt; /proc/sys/kernel/hotplugmdev -smkdir -p /dev/ptsmkdir -p /dev/i2cmount -t devpts devpts /dev/ptsecho \"rcS Complete\"为其添加执行权限和所属用户组:12$ chmod 755 etc/init.d/rcS$ sudo chown root:root etc/init.d/rcSpasswd文件新建etc/passwd文件, 并添加以下内容:[src]etc/passwd1root:$1$qC.CEbjC$SVJyqm.IG.gkElhaeM.FD0:0:0:root:/root:/bin/sh现在根文件系统已经制作完成, 接下来就要制作成ramdisk image.制作ramdisk制作新的ramdisk.image文件系统格式为ext2, 大小为16M:1234$ dd if=/dev/zero of=ramdisk.image bs=1024 count=16384$ mke2fs -F ramdisk.image -L \"ramdisk\" -b 1024 -m 0$ tune2fs ramdisk.image -i 0$ chmod 777 ramdisk.image挂载ramdisk新建一个rootfs目录, 并将ramdisk.image挂载到rootfs目录:123$ mkdir rootfs$ chmod u+rwx ramdisk.image$ sudo mount -o loop ramdisk.image rootfs将制作好的根文件系统全部拷贝到rootfs目录下:1$ cp -af root/* rootfs/*打包ramdisk卸载rootfs, 并打包ramdisk.image:123$ sudo umount rootfs$ gzip ramdisk.image$ mkimage -A arm -T ramdisk -C gzip -d ramdisk.image.gz uramdisk.image.gz使用将ramdisk.image.gz拷贝到/mnt/workspace/linux/output目录下, 执行:1$ mk_kernel.sh &amp;&amp; mk_sdimage.sh将/mnt/workspace/linux/images/sd_image目录下的生成文件拷贝到SD卡, 重新上电, 启动后如下:123456[root@skycaster ]# pwd/[root@skycaster ]# lsbin home mnt sbin usrdev lib proc sys varetc lost+found root tmp测试环境@系统: Windows 7 Professional with SP1@Vivado: 2015.04@虚拟机: OSRC_Miz7_ubuntu_14@开发板: 米联MIZ702N参考文章(原创)一步一步学ZedBoard &amp; Zynq(七)：制作ZedBoard上linux根文件系统(ramdisk)最新busybox-1.28.1制作根文件系统","categories":[{"name":"xilinx","slug":"xilinx","permalink":"http://hanoi404.github.io/categories/xilinx/"}],"tags":[{"name":"xilinx","slug":"xilinx","permalink":"http://hanoi404.github.io/tags/xilinx/"},{"name":"ramdisk","slug":"ramdisk","permalink":"http://hanoi404.github.io/tags/ramdisk/"},{"name":"linux","slug":"linux","permalink":"http://hanoi404.github.io/tags/linux/"}]},{"title":"ZYNQ 烧录QSPI FLASH及从QSPI启动","slug":"zynq-qspi-02","date":"2018-08-06T06:21:41.000Z","updated":"2018-08-20T01:28:30.000Z","comments":true,"path":"622008616/","link":"","permalink":"http://hanoi404.github.io/622008616/","excerpt":"ZYNQ Linux启动方式由于ZYNQ采用的是PS(ARM A9双核)+PL(FPGA)设计, 整个启动过程比较复杂, 因此我们从嵌入式Linux软件层面的角度考虑, 将ZYNQ当作一块纯ARM开发板, 从而简化ZYNQ的启动流程.SD卡和QSPI启动流程ZYNQ跑Linux系统, 在实际情况中用得比较多的启动方法为SD卡启动和QSPI启动, 先看下这两种方式的启动流程:","text":"ZYNQ Linux启动方式由于ZYNQ采用的是PS(ARM A9双核)+PL(FPGA)设计, 整个启动过程比较复杂, 因此我们从嵌入式Linux软件层面的角度考虑, 将ZYNQ当作一块纯ARM开发板, 从而简化ZYNQ的启动流程.SD卡和QSPI启动流程ZYNQ跑Linux系统, 在实际情况中用得比较多的启动方法为SD卡启动和QSPI启动, 先看下这两种方式的启动流程:QSPI启动123456设置板子为QSPI启动 ----&gt; 上电启动 ---&gt; 从Flash加载BOOT.bin(fsbl.elf, system.bit, u-boot.elf) ---&gt; 进入U-BOOT ---&gt; 解析bootargs(将kernel, devicetree, ramdisk 从Flash加载到内存指定地址) ---&gt; 使用bootm命令启动LinuxSD卡启动123456设置板子为SD卡启动 ----&gt; 上电启动 ---&gt; 从SD卡加载BOOT.bin(fsbl.elf, system.bit, u-boot.elf) ---&gt; 进入U-BOOT ---&gt; 解析bootargs(将kernel, devicetree, ramdisk 从SD卡加载到内存指定地址) ---&gt; 使用bootm命令启动LinuxSD卡和QSPI启动Linux的bootargsU-boot中这两种启动方式的boottargs定义:[src]bootloader/include/configs/zynq-common.h12345678910111213141516171819202122232425262728293031...\"kernel_image=uImage\\0\" \\\"kernel_load_address=0x2080000\\0\" \\\"ramdisk_image=uramdisk.image.gz\\0\" \\\"ramdisk_load_address=0x4000000\\0\" \\\"devicetree_image=devicetree.dtb\\0\" \\\"devicetree_load_address=0x2000000\\0\" \\\"bitstream_image=system.bit.bin\\0\" \\\"boot_image=BOOT.bin\\0\" \\...\"kernel_size=0x500000\\0\" \\\"devicetree_size=0x20000\\0\" \\\"ramdisk_size=0x800000\\0\"...\"qspiboot=echo Copying Linux from QSPI flash to RAM... &amp;&amp; \" \\ \"sf probe 0 0 0 &amp;&amp; \" \\ \"sf read $&#123;kernel_load_address&#125; 0x500000 $&#123;kernel_size&#125; &amp;&amp; \" \\ \"sf read $&#123;devicetree_load_address&#125; 0xA00000 $&#123;devicetree_size&#125; &amp;&amp; \" \\ \"echo Copying ramdisk... &amp;&amp; \" \\ \"sf read $&#123;ramdisk_load_address&#125; 0xA20000 $&#123;ramdisk_size&#125; &amp;&amp; \" \\ \"bootm $&#123;kernel_load_address&#125; $&#123;ramdisk_load_address&#125; $&#123;devicetree_load_address&#125;\\0\" \\...\"sdboot=if mmcinfo; then \" \\ \"run uenvboot; \" \\ \"echo Copying Linux from SD to RAM... &amp;&amp; \" \\ \"load mmc 0 $&#123;kernel_load_address&#125; $&#123;kernel_image&#125; &amp;&amp; \" \\ \"load mmc 0 $&#123;devicetree_load_address&#125; $&#123;devicetree_image&#125; &amp;&amp; \" \\ \"load mmc 0 $&#123;ramdisk_load_address&#125; $&#123;ramdisk_image&#125; &amp;&amp; \" \\ \"bootm $&#123;kernel_load_address&#125; $&#123;ramdisk_load_address&#125; $&#123;devicetree_load_address&#125;; \" \\ \"fi\\0\" \\...分别看下u-boot中sf和load命令:12345678// sf: 用于spi/qspi flash的读/写/擦除操作;// read/write/erase之前必须先调用sf probe;// 具体用法:sf probe [[bus:]cs] [hz] [mode] - init flash device on given SPI bus and chip selectsf read addr offset len - read `len' bytes starting at`offset' to memory at `addr'sf write addr offset len - write `len' bytes from memor at `addr' to flash at `offset'sf erase offset [+]len - erase `len' bytes from `offset' `+len' round up `len' to block sizesf update addr offset len - erase and write `len' bytes from memory at `addr' to flash at `offset'12345678910// load: 用于读取文件系统中的二进制文件;// 从SD卡启动, mmc 0 为SD卡;// 具体用法:load &lt;interface&gt; [&lt;dev[:part]&gt; [&lt;addr&gt; [&lt;filename&gt; [bytes [pos]]]]] - Load binary file 'filename' from partition 'part' on device type 'interface' instance 'dev' to address 'addr' in memory. 'bytes' gives the size to load in bytes. If 'bytes' is 0 or omitted, the file is read until the end. 'pos' gives the file byte position to start reading from. If 'pos' is 0 or omitted, the file is read from the start.通过对比我们可以看出SD卡和QSPI启动Linux的区别主要在于:前者从SD卡中将uImage, uramdisk.image.gz, devicetree.dtb文件加载到内存指定位置, 而后者从qspi flash 指定地址(分区)中加载到内存.Tips:qspiboot中读取Flash时使用的三个地址偏移0x500000, 0xA00000, 0xA20000, 需要根据实际情况进行配置.QSPI FLASH烧录U-boot下烧录SD卡启动文件到QSPI Flash设置板子为SD卡启动, 上电后进入U-boot命令行:123456789101112131415161718Zynq&gt; ls mmc 0 # 查看SD卡目录结构;Zynq&gt; sf probe 0 0 0 # 初始化SPI FLASH Zynq&gt; fatload mmc 0 0x08000000 BOOT.bin # 从SD卡加载BOOT.bin到内存地址0x08000000;Zynq&gt; sf erase 0x0 0x500000 # 擦除Flash 0x0地址处大小为0x500000的空间;Zynq&gt; sf write 0x8000000 0x0 0x500000 # 将内存地址0x08000000起始处的0x500000的大小内容写进Flash地址0x0处; Zynq&gt; fatload mmc 0 0x08000000 uImage # 从SD卡加载uImage到内存地址0x08000000;Zynq&gt; sf erase 0x500000 0x500000 # 擦除Flash 0x500000地址处大小为0x500000的空间;Zynq&gt; sf write 0x8000000 0x500000 0x500000 # 将内存地址0x08000000起始处的0x500000的大小内容写进Flash地址0x500000处; Zynq&gt; fatload mmc 0 0x08000000 devicetree.dtb # 从SD卡加载devicetree.dtb到内存地址0x08000000;Zynq&gt; sf erase 0xA00000 0x20000 # 擦除Flash 0xA00000地址处大小为0x20000的空间;Zynq&gt; sf write 0x8000000 0xA00000 0x20000 # 将内存地址0x08000000起始处的0x20000的大小内容写进Flash地址0xA00000处; Zynq&gt; fatload mmc 0 0x08000000 uramdisk.image.gz # 从SD卡加载uramdisk.image.gz到内存地址0x08000000;Zynq&gt; sf erase 0xA20000 0x800000 # 擦除Flash 0xA20000地址处大小为0x500000的空间;Zynq&gt; sf write 0x8000000 0xA20000 0x800000 # 将内存地址0x08000000起始处的0x800000的大小内容写进Flash地址0xA20000处;设置板子为QSPI启动, 重新上电, 成功进入系统.制作QSPI启动镜像直接烧写SD卡启动文件似乎有点复杂, 那么我们就制作单独的QSPI启动镜像文件, 简化烧录过程; 首先我们看看制作SD卡启动文件脚本的主要内容:scripts/mk_sd_image.sh123456789101112131415...echo \"//arch = zynq; split = false; format = BIN\" &gt; $&#123;TARGET&#125;/sd_image.bifecho \"the_ROM_image:\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \"&#123;\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \" [bootloader]$&#123;TARGET&#125;/fsbl.elf\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \" $&#123;TARGET&#125;/system_wrapper.bit\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \" $&#123;TARGET&#125;/u-boot.elf\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \"&#125;\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bif...bootgen -image $&#123;TARGET&#125;/sd_image.bif -o $&#123;IMAGES&#125;/sd_image/BOOT.bin -w on...cp -a $&#123;TARGET&#125;/uImage $&#123;IMAGES&#125;/sd_image/cp -a $&#123;TARGET&#125;/devicetree.dtb $&#123;IMAGES&#125;/sd_image/cp -a $&#123;TARGET&#125;/uramdisk.image.gz $&#123;IMAGES&#125;/sd_image/...从这一段内容可以看出BOOT.bin是由sd_image.bif打包生成的; 而sd_image.bif是由fsbl.elf, system_wrapper.bit, boot.elf三个文件组成, 基本格式为:123456the_ROM_image:&#123; [bootloader]fsbl.elf system_wrapper.bit boot.elf&#125;剩下的uImage, devicetree.dtb, uramdisk.image.gz则是直接拷贝过来的; 那么我们将bif文件的格式加入偏移后变成:123456789the_ROM_image:&#123; [bootloader]fsbl.elf system_wrapper.bit boot.elf [offset = 0x500000]uImage.bin [offset = 0xA00000]devicetree.dtb [offset = 0xA20000]uramdisk.image.gz&#125;这样就将所有需要的启动文件打包成一个文件.Tips:注意这里的offset要与bootargs中的偏移一致才能正确读取各个部分内容.修改mk_sd_image.sh的内容, 保存为mk_qspi_image.sh[src]scripts/mk_qspi_image.sh12345678910111213141516171819202122232425...BIF_FILE=$&#123;TARGET&#125;/qspi_image.bif# startecho \"//arch = zynq; split = false; format = BIN\" &gt; $&#123;BIF_FILE&#125;echo \"the_ROM_image:\" &gt;&gt;$&#123;BIF_FILE&#125;echo \"&#123;\" &gt;&gt;$&#123;BIF_FILE&#125;# The files we need are:# 1. the first stage boot loaderecho \" [bootloader]$&#123;TARGET&#125;/fsbl.elf\" &gt;&gt;$&#123;BIF_FILE&#125;# 2. FPGA bit streamif [ -f \"$&#123;TARGET&#125;/system_wrapper.bit\" ]; then echo \" $&#123;TARGET&#125;/system_wrapper.bit\" &gt;&gt;$&#123;BIF_FILE&#125;fi# 3. Das U-Boot boot loaderecho \" $&#123;TARGET&#125;/u-boot.elf\" &gt;&gt;$&#123;BIF_FILE&#125;# 4. Linux kernel with modified header for U-Bootecho \" [offset = 0x500000]$&#123;TARGET&#125;/uImage.bin\" &gt;&gt;$&#123;BIF_FILE&#125;# 5. Device tree blobecho \" [offset = 0xA00000]$&#123;TARGET&#125;/devicetree.dtb\" &gt;&gt;$&#123;BIF_FILE&#125;# 6. Root filesystemecho \" [offset = 0xA20000]$&#123;TARGET&#125;/uramdisk.image.gz\" &gt;&gt;$&#123;BIF_FILE&#125;echo \"&#125;\" &gt;&gt;$&#123;BIF_FILE&#125;# endbootgen -image $&#123;TARGET&#125;/qspi_image.bif -o $&#123;IMAGES&#125;/qspi_image/qspi_image.bin -w on...执行以下脚本生成image/qspi_image/qspi_image.bin, 文件大小接近18MB.1# mk_bootloader.sh &amp;&amp; mk_kernel.sh &amp;&amp; mk_qspi_image.sh烧录时执行以下命令即可:123Zynq&gt; fatload mmc 0 0x08000000 qspi_image.bin # 从SD卡加载qspi_image.bin到内存地址0x08000000;Zynq&gt; sf erase 0x0 0x1200000 # 擦除Flash 0x0地址处大小为0x1200000的空间;Zynq&gt; sf write 0x8000000 0x0 0x1200000 # 将内存地址0x08000000起始处的0x1200000的大小内容写进Flash地址0x0处;启动Linux后烧录启动文件到QSPI Flash在Linux下可以将bin文件通过dd 命令直接写进Flash中. 首先要配置QSPI Flash驱动, 生成MTD设备节点. 在Kernel源码路径输入命令:1# make ARCH=arm menuconfig选择以下配置选项:12345678Device Drivers ---&gt; &lt;*&gt; Memory Technology Device (MTD) support ---&gt; Self-contained MTD device drivers ---&gt; &lt;*&gt; Support most SPI Flash chips (AT26DF, M25P, W25X, ...) &lt;*&gt; SPI-NOR device support ---&gt; [*] SPI support ---&gt; &lt;*&gt; Xilinx SPI controller common module &lt;*&gt; Xilinx Zynq QSPI controller修改设备树:[src]kernel/arch/arm/boot/dts/zynq-zed.dts12345678910111213141516171819202122 ... aliases &#123; ... spi0 = &amp;qspi; ... &#125;; ...&amp;qspi &#123; status = &quot;okay&quot;; is-dual = &lt;0&gt;; num-cs = &lt;1&gt;; flash@0 &#123; compatible = &quot;n25q128a11&quot;; reg = &lt;0x0&gt;; spi-tx-bus-width = &lt;1&gt;; spi-rx-bus-width = &lt;4&gt;; spi-max-frequency = &lt;50000000&gt;; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; &#125;;&#125;;...在flash子节点下可以自己添加分区, 格式为[src]kernel/arch/arm/boot/dts/zynq-zed.dts12345678910111213141516partition@qspi-fsbl-uboot &#123; label = &quot;qspi-fsbl-uboot&quot;; reg = &lt;0x0 0x500000&gt;;&#125;;partition@qspi-linux &#123; label = &quot;qspi-linux&quot;; reg = &lt;0x500000 0x500000&gt;;&#125;;partition@qspi-device-tree &#123; label = &quot;qspi-device-tree&quot;; reg = &lt;0xA00000 0x20000&gt;; &#125;;partition@qspi-rootfs &#123; label = &quot;qspi-rootfs&quot;; reg = &lt;0xA20000 0x800000&gt;;&#125;;执行以下脚本生成qspi_image.bin:1# mk_bootloader.sh &amp;&amp; mk_kernel.sh &amp;&amp; mk_qspi_image.sh拷贝生成文件到SD卡, 上电启动, 进入系统, 查看设备节点和MTD分区信息:12345# ls /dev/mtd*/dev/mtd0 /dev/mtd0ro /dev/mtdblock0# cat /proc/mtd dev: size erasesize namemtd0: 02000000 00010000 &quot;spi0.0&quot;使用dd命令烧录QSPI Flash:123# dd if=&lt;sdcard_root_dir&gt;/qspi_image.bin of=/dev/mtdblock0 bs=102417687+1 records in17687+1 records out重新启动开发板, 进入系统, OK.测试环境@系统: Windows 7 Professional with SP1@Vivado: 2015.04@虚拟机: OSRC_Miz7_ubuntu_14@开发板: 米联MIZ702N参考文章[移植篇] CH04 LINUX从QSPI启动","categories":[{"name":"xilinx","slug":"xilinx","permalink":"http://hanoi404.github.io/categories/xilinx/"}],"tags":[{"name":"xilinx","slug":"xilinx","permalink":"http://hanoi404.github.io/tags/xilinx/"},{"name":"qspi","slug":"qspi","permalink":"http://hanoi404.github.io/tags/qspi/"}]},{"title":"ZYNQ QSPI驱动分析","slug":"zynq-qspi-01","date":"2018-08-03T03:52:41.000Z","updated":"2018-08-20T01:28:35.872Z","comments":true,"path":"1064320173/","link":"","permalink":"http://hanoi404.github.io/1064320173/","excerpt":"ZYNQ QSPI框架接口首先, 我们要知道: SPI Nor层完成MTD子系统的接口和Norflash操作硬件接口的转化, 而SPI Master层完成操作硬件时数据传输的协议制定.那么一次读写Norflash过程可以简化为:1234file system(open, read, write) -&gt; mtd sub system(mtd_open, mtd_read, mtd_write) -&gt; nor flash(m25p80_read, m25p80_write) -&gt; hardware","text":"ZYNQ QSPI框架接口首先, 我们要知道: SPI Nor层完成MTD子系统的接口和Norflash操作硬件接口的转化, 而SPI Master层完成操作硬件时数据传输的协议制定.那么一次读写Norflash过程可以简化为:1234file system(open, read, write) -&gt; mtd sub system(mtd_open, mtd_read, mtd_write) -&gt; nor flash(m25p80_read, m25p80_write) -&gt; hardware再来看下整个qspi框架的主要接口:12345678910111213----------------|------------------------------------------------------------MTD Sub System |----------------|------------------------------------------------------------ | spi_nor_read spi_nor_write spi_nor_lock spi_nor_unlockSPI Nor |------------------------------------------------------------ | m25p80_read m25p80_write m25p80_read_reg m25p80_write_reg----------------|------------------------------------------------------------ | spi_write spi_sync spi_write_then_readSPI Master |------------------------------------------------------------ | zynq_qspi_setup zynq_qspi_start_transfer----------------|------------------------------------------------------------Hardware |----------------|------------------------------------------------------------ZYNQ QSPI驱动注册过程QSPI驱动主要分为2个部分: SPI Master部分完成主控的硬件初始化以及配置SPI总线地址, 位宽, 模式, 速度等; Norflash部分实现了操作Flash硬件的接口和MTD子系统的读/写/擦除Flash接口.SPI Master驱动注册在驱动入口函数zynq_qspi_probe中, 完成对QSPI主控制器的一系列初始化:[src]driver/spi/spi-zynq-qspi.c123456789101112static int zynq_qspi_probe(struct platform_device *pdev)&#123; ... /* QSPI controller initializations */ zynq_qspi_init_hw(xqspi); ... master-&gt;setup = zynq_qspi_setup; master-&gt;set_cs = zynq_qspi_chipselect; master-&gt;transfer_one = zynq_qspi_start_transfer; master-&gt;prepare_transfer_hardware = zynq_prepare_transfer_hardware; ...&#125;最后调用spi_register_master()创建设备节点/dev/spiX.X[src]driver/spi/spi-zynq-qspi.c12345678910static int zynq_qspi_probe(struct platform_device *pdev)&#123; ... ret = spi_register_master(master); if (ret) &#123; dev_err(&amp;pdev-&gt;dev, \"spi_register_master failed\\n\"); goto clk_dis_all; &#125; ...&#125;在spi_register_master函数的最后, 调用了of_register_spi_device来遍历子节点[src]driver/spi/spi.c1234567int spi_register_master(struct spi_master *master)&#123; ... /* Register devices from the device tree and ACPI */ of_register_spi_devices(master); ...&#125;在该函数中读取设备树上的配置信息, 初始化SPI BUS[src]driver/spi/spi.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static void of_register_spi_devices(struct spi_master *master)&#123; ... /* Alloc an spi_device */ spi = spi_alloc_device(master); ... /* Select device driver */ rc = of_modalias_node(nc, spi-&gt;modalias, sizeof(spi-&gt;modalias)); ... /* Device address */ rc = of_property_read_u32(nc, \"reg\", &amp;value); spi-&gt;chip_select = value; ... /* Mode (clock phase/polarity/etc.) */ if (of_find_property(nc, \"spi-cpha\", NULL)) spi-&gt;mode |= SPI_CPHA; if (of_find_property(nc, \"spi-cpol\", NULL)) spi-&gt;mode |= SPI_CPOL; if (of_find_property(nc, \"spi-cs-high\", NULL)) spi-&gt;mode |= SPI_CS_HIGH; if (of_find_property(nc, \"spi-3wire\", NULL)) spi-&gt;mode |= SPI_3WIRE; if (of_find_property(nc, \"spi-lsb-first\", NULL)) spi-&gt;mode |= SPI_LSB_FIRST; /* Device DUAL/QUAD mode */ if (!of_property_read_u32(nc, \"spi-tx-bus-width\", &amp;value)) &#123; switch (value) &#123; case 1: break; case 2: spi-&gt;mode |= SPI_TX_DUAL; break; case 4: spi-&gt;mode |= SPI_TX_QUAD; break; default: dev_warn(&amp;master-&gt;dev, \"spi-tx-bus-width %d not supported\\n\", value); break; &#125; &#125; if (!of_property_read_u32(nc, \"spi-rx-bus-width\", &amp;value)) &#123; switch (value) &#123; case 1: break; case 2: spi-&gt;mode |= SPI_RX_DUAL; break; case 4: spi-&gt;mode |= SPI_RX_QUAD; break; default: dev_warn(&amp;master-&gt;dev, \"spi-rx-bus-width %d not supported\\n\", value); break; &#125; &#125; /* Device speed */ rc = of_property_read_u32(nc, \"spi-max-frequency\", &amp;value); spi-&gt;max_speed_hz = value; ...&#125;Norflash驱动注册在of_register_spi_device函数的最后, 调用spi_add_device来加载m25p80设备驱动[src]driver/spi/spi.c1234567static void of_register_spi_devices(struct spi_master *master)&#123; ... /* Register the new device */ rc = spi_add_device(spi); ...&#125;在m25p_probe函数中, 配置spi nor的read/write(读写nor flash), read_reg(配置qspi寄存器), write_reg(配置nor flash寄存器)[src]drivers/mtd/devices/m25p80.c123456789static int m25p_probe(struct spi_device *spi)&#123; ... nor-&gt;read = m25p80_read; nor-&gt;write = m25p80_write; nor-&gt;write_reg = m25p80_write_reg; nor-&gt;read_reg = m25p80_read_reg; ...&#125;调用spi_nor_scan函数, 获取id, 得到nor flash信息, 然后配置type, writesize, size等参数, 设置_erase, _read, _write回调函数[src]drivers/mtd/devices/m25p80.c1234567891011121314int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)&#123; ... jinfo = spi_nor_read_id(nor); ... mtd-&gt;priv = nor; mtd-&gt;type = MTD_NORFLASH; mtd-&gt;writesize = 1; mtd-&gt;flags = MTD_CAP_NORFLASH; mtd-&gt;size = info-&gt;sector_size * info-&gt;n_sectors; mtd-&gt;_erase = spi_nor_erase; mtd-&gt;_read = spi_nor_read_ext; ...&#125;调用mtd_device_register函数, 解析设备树中的分区表, 添加分区信息[src]drivers/mtd/mtdcore.c1234567891011int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types, struct mtd_part_parser_data *parser_data, const struct mtd_partition *parts, int nr_parts)&#123; ... ret = parse_mtd_partitions(mtd, types, &amp;parsed, parser_data); ... ret = mtd_add_device_partitions(mtd, &amp;parsed); ...&#125;参考文章Linux SPI/QSPI nor flash相关驱动代码","categories":[{"name":"xilinx","slug":"xilinx","permalink":"http://hanoi404.github.io/categories/xilinx/"}],"tags":[{"name":"xilinx","slug":"xilinx","permalink":"http://hanoi404.github.io/tags/xilinx/"},{"name":"qspi","slug":"qspi","permalink":"http://hanoi404.github.io/tags/qspi/"}]}]}