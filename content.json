{"meta":{"title":"BALOST","subtitle":null,"description":null,"author":"BALOST","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-07-23T03:56:24.000Z","updated":"2018-07-23T04:21:16.843Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-23T04:23:23.000Z","updated":"2018-07-23T04:29:24.325Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ZYNQ 烧录QSPI FLASH及从QSPI启动","slug":"zynq-qspi-02","date":"2018-08-06T06:21:41.000Z","updated":"2018-08-07T09:12:33.670Z","comments":true,"path":"622008616/","link":"","permalink":"http://yoursite.com/622008616/","excerpt":"","text":"ZYNQ Linux启动方式由于ZYNQ采用的是PS(ARM A9双核)+PL(FPGA)设计, 整个启动过程比较复杂, 因此我们从嵌入式Linux软件层面的角度考虑, 将ZYNQ当作一块纯ARM开发板, 从而简化ZYNQ的启动流程.SD卡和QSPI启动流程ZYNQ跑Linux系统, 在实际情况中用得比较多的启动方法为SD卡启动和QSPI启动, 先看下这两种方式的启动流程:QSPI启动123456设置板子为QSPI启动 ----&gt; 上电启动 ---&gt; 从Flash加载BOOT.bin(fsbl.elf, system.bit, u-boot.elf) ---&gt; 进入U-BOOT ---&gt; 解析bootargs(将kernel, devicetree, ramdisk 从Flash加载到内存指定地址) ---&gt; 使用bootm命令启动LinuxSD卡启动123456设置板子为SD卡启动 ----&gt; 上电启动 ---&gt; 从SD卡加载BOOT.bin(fsbl.elf, system.bit, u-boot.elf) ---&gt; 进入U-BOOT ---&gt; 解析bootargs(将kernel, devicetree, ramdisk 从SD卡加载到内存指定地址) ---&gt; 使用bootm命令启动LinuxSD卡和QSPI启动Linux的bootargsU-boot中这两种启动方式的boottargs定义:bootloader/include/configs/zynq-common.h12345678910111213141516171819202122232425262728293031 ...\"kernel_image=uImage\\0\" \\\"kernel_load_address=0x2080000\\0\" \\\"ramdisk_image=uramdisk.image.gz\\0\" \\\"ramdisk_load_address=0x4000000\\0\" \\\"devicetree_image=devicetree.dtb\\0\" \\\"devicetree_load_address=0x2000000\\0\" \\\"bitstream_image=system.bit.bin\\0\" \\\"boot_image=BOOT.bin\\0\" \\...\"kernel_size=0x500000\\0\" \\\"devicetree_size=0x20000\\0\" \\\"ramdisk_size=0x800000\\0\"...\"qspiboot=echo Copying Linux from QSPI flash to RAM... &amp;&amp; \" \\ \"sf probe 0 0 0 &amp;&amp; \" \\ \"sf read $&#123;kernel_load_address&#125; 0x500000 $&#123;kernel_size&#125; &amp;&amp; \" \\ \"sf read $&#123;devicetree_load_address&#125; 0xA00000 $&#123;devicetree_size&#125; &amp;&amp; \" \\ \"echo Copying ramdisk... &amp;&amp; \" \\ \"sf read $&#123;ramdisk_load_address&#125; 0xA20000 $&#123;ramdisk_size&#125; &amp;&amp; \" \\ \"bootm $&#123;kernel_load_address&#125; $&#123;ramdisk_load_address&#125; $&#123;devicetree_load_address&#125;\\0\" \\...\"sdboot=if mmcinfo; then \" \\ \"run uenvboot; \" \\ \"echo Copying Linux from SD to RAM... &amp;&amp; \" \\ \"load mmc 0 $&#123;kernel_load_address&#125; $&#123;kernel_image&#125; &amp;&amp; \" \\ \"load mmc 0 $&#123;devicetree_load_address&#125; $&#123;devicetree_image&#125; &amp;&amp; \" \\ \"load mmc 0 $&#123;ramdisk_load_address&#125; $&#123;ramdisk_image&#125; &amp;&amp; \" \\ \"bootm $&#123;kernel_load_address&#125; $&#123;ramdisk_load_address&#125; $&#123;devicetree_load_address&#125;; \" \\ \"fi\\0\" \\...分别看下u-boot中sf和load命令:12345678// sf: 用于spi/qspi flash的读/写/擦除操作;// read/write/erase之前必须先调用sf probe;// 具体用法:sf probe [[bus:]cs] [hz] [mode] - init flash device on given SPI bus and chip selectsf read addr offset len - read `len' bytes starting at`offset' to memory at `addr'sf write addr offset len - write `len' bytes from memor at `addr' to flash at `offset'sf erase offset [+]len - erase `len' bytes from `offset' `+len' round up `len' to block sizesf update addr offset len - erase and write `len' bytes from memory at `addr' to flash at `offset'12345678910// load: 用于读取文件系统中的二进制文件;// 从SD卡启动, mmc 0 为SD卡;// 具体用法:load &lt;interface&gt; [&lt;dev[:part]&gt; [&lt;addr&gt; [&lt;filename&gt; [bytes [pos]]]]] - Load binary file 'filename' from partition 'part' on device type 'interface' instance 'dev' to address 'addr' in memory. 'bytes' gives the size to load in bytes. If 'bytes' is 0 or omitted, the file is read until the end. 'pos' gives the file byte position to start reading from. If 'pos' is 0 or omitted, the file is read from the start.通过对比我们可以看出SD卡和QSPI启动Linux的区别主要在于:前者从SD卡中将uImage, uramdisk.image.gz, devicetree.dtb文件加载到内存指定位置, 而后者从qspi flash 指定地址(分区)中加载到内存.Tips:qspiboot中读取Flash时使用的三个地址偏移0x500000, 0xA00000, 0xA20000, 需要根据实际情况进行配置.QSPI FLASH烧录U-boot下烧录SD卡启动文件到QSPI Flash设置板子为SD卡启动, 上电后进入U-boot命令行:123456789101112131415161718Zynq&gt; ls mmc 0 # 查看SD卡目录结构;Zynq&gt; sf probe 0 0 0 # 初始化SPI FLASH Zynq&gt; fatload mmc 0 0x08000000 BOOT.bin # 从SD卡加载BOOT.bin到内存地址0x08000000;Zynq&gt; sf erase 0x0 0x500000 # 擦除Flash 0x0地址处大小为0x500000的空间;Zynq&gt; sf write 0x8000000 0x0 0x500000 # 将内存地址0x08000000起始处的0x500000的大小内容写进Flash地址0x0处;Zynq&gt; fatload mmc 0 0x08000000 uImage # 从SD卡加载uImage到内存地址0x08000000;Zynq&gt; sf erase 0x500000 0x500000 # 擦除Flash 0x500000地址处大小为0x500000的空间;Zynq&gt; sf write 0x8000000 0x500000 0x500000 # 将内存地址0x08000000起始处的0x500000的大小内容写进Flash地址0x500000处;Zynq&gt; fatload mmc 0 0x08000000 devicetree.dtb # 从SD卡加载devicetree.dtb到内存地址0x08000000;Zynq&gt; sf erase 0xA00000 0x20000 # 擦除Flash 0xA00000地址处大小为0x20000的空间;Zynq&gt; sf write 0x8000000 0xA00000 0x20000 # 将内存地址0x08000000起始处的0x20000的大小内容写进Flash地址0xA00000处;Zynq&gt; fatload mmc 0 0x08000000 uramdisk.image.gz # 从SD卡加载uramdisk.image.gz到内存地址0x08000000;Zynq&gt; sf erase 0xA20000 0x800000 # 擦除Flash 0xA20000地址处大小为0x500000的空间;Zynq&gt; sf write 0x8000000 0xA20000 0x800000 # 将内存地址0x08000000起始处的0x800000的大小内容写进Flash地址0xA20000处;设置板子为QSPI启动, 重新上电, 成功进入系统.制作QSPI启动镜像直接烧写SD卡启动文件似乎有点复杂, 那么我们就制作单独的QSPI启动镜像文件, 简化烧录过程; 首先我们看看制作SD卡启动文件脚本的主要内容:scripts/mk_sd_image.sh123456789101112131415...echo \"//arch = zynq; split = false; format = BIN\" &gt; $&#123;TARGET&#125;/sd_image.bifecho \"the_ROM_image:\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \"&#123;\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \" [bootloader]$&#123;TARGET&#125;/fsbl.elf\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \" $&#123;TARGET&#125;/system_wrapper.bit\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \" $&#123;TARGET&#125;/u-boot.elf\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bifecho \"&#125;\" &gt;&gt;$&#123;TARGET&#125;/sd_image.bif...bootgen -image $&#123;TARGET&#125;/sd_image.bif -o $&#123;IMAGES&#125;/sd_image/BOOT.bin -w on...cp -a $&#123;TARGET&#125;/uImage $&#123;IMAGES&#125;/sd_image/cp -a $&#123;TARGET&#125;/devicetree.dtb $&#123;IMAGES&#125;/sd_image/cp -a $&#123;TARGET&#125;/uramdisk.image.gz $&#123;IMAGES&#125;/sd_image/...从这一段内容可以看出BOOT.bin是由sd_image.bif打包生成的; 而sd_image.bif是由fsbl.elf, system_wrapper.bit, boot.elf三个文件组成, 基本格式为:123456the_ROM_image:&#123; [bootloader]fsbl.elf system_wrapper.bit boot.elf&#125;剩下的uImage, devicetree.dtb, uramdisk.image.gz则是直接拷贝过来的; 那么我们将bif文件的格式加入偏移后变成:123456789the_ROM_image:&#123; [bootloader]fsbl.elf system_wrapper.bit boot.elf [offset = 0x500000]uImage.bin [offset = 0xA00000]devicetree.dtb [offset = 0xA20000]uramdisk.image.gz&#125;这样就将所有需要的启动文件打包成一个文件.Tips:注意这里的offset要与bootargs中的偏移一致才能正确读取各个部分内容.修改mk_sd_image.sh的内容, 保存为mk_qspi_image.shscripts/mk_qspi_image.sh12345678910111213141516171819202122232425...BIF_FILE=$&#123;TARGET&#125;/qspi_image.bif# startecho \"//arch = zynq; split = false; format = BIN\" &gt; $&#123;BIF_FILE&#125;echo \"the_ROM_image:\" &gt;&gt;$&#123;BIF_FILE&#125;echo \"&#123;\" &gt;&gt;$&#123;BIF_FILE&#125;# The files we need are:# 1. the first stage boot loaderecho \" [bootloader]$&#123;TARGET&#125;/fsbl.elf\" &gt;&gt;$&#123;BIF_FILE&#125;# 2. FPGA bit streamif [ -f \"$&#123;TARGET&#125;/system_wrapper.bit\" ]; then echo \" $&#123;TARGET&#125;/system_wrapper.bit\" &gt;&gt;$&#123;BIF_FILE&#125;fi# 3. Das U-Boot boot loaderecho \" $&#123;TARGET&#125;/u-boot.elf\" &gt;&gt;$&#123;BIF_FILE&#125;# 4. Linux kernel with modified header for U-Bootecho \" [offset = 0x500000]$&#123;TARGET&#125;/uImage.bin\" &gt;&gt;$&#123;BIF_FILE&#125;# 5. Device tree blobecho \" [offset = 0xA00000]$&#123;TARGET&#125;/devicetree.dtb\" &gt;&gt;$&#123;BIF_FILE&#125;# 6. Root filesystemecho \" [offset = 0xA20000]$&#123;TARGET&#125;/uramdisk.image.gz\" &gt;&gt;$&#123;BIF_FILE&#125;echo \"&#125;\" &gt;&gt;$&#123;BIF_FILE&#125;# endbootgen -image $&#123;TARGET&#125;/qspi_image.bif -o $&#123;IMAGES&#125;/qspi_image/qspi_image.bin -w on...执行以下脚本生成image/qspi_image/qspi_image.bin, 文件大小接近18MB.1# mk_bootloader.sh &amp;&amp; mk_kernel.sh &amp;&amp; mk_qspi_image.sh烧录时执行以下命令即可:123Zynq&gt; fatload mmc 0 0x08000000 qspi_image.bin # 从SD卡加载qspi_image.bin到内存地址0x08000000;Zynq&gt; sf erase 0x0 0x1200000 # 擦除Flash 0x0地址处大小为0x1200000的空间;Zynq&gt; sf write 0x8000000 0x0 0x1200000 # 将内存地址0x08000000起始处的0x1200000的大小内容写进Flash地址0x0处;启动Linux后烧录启动文件到QSPI Flash在Linux下可以将bin文件通过dd 命令直接写进Flash中. 首先要配置QSPI Flash驱动, 生成MTD设备节点. 在Kernel源码路径输入命令:1# make ARCH=arm menuconfig选择以下配置选项:12345678Device Drivers ---&gt; &lt;*&gt; Memory Technology Device (MTD) support ---&gt; Self-contained MTD device drivers ---&gt; &lt;*&gt; Support most SPI Flash chips (AT26DF, M25P, W25X, ...) &lt;*&gt; SPI-NOR device support ---&gt; [*] SPI support ---&gt; &lt;*&gt; Xilinx SPI controller common module &lt;*&gt; Xilinx Zynq QSPI controller修改设备树:kernel/arch/arm/boot/dts/zynq-zed.dts12345678910111213141516171819202122...aliases &#123;...spi0 = &amp;qspi;...&#125;;...&amp;qspi &#123; status = &quot;okay&quot;; is-dual = &lt;0&gt;; num-cs = &lt;1&gt;; flash@0 &#123; compatible = &quot;n25q128a11&quot;; reg = &lt;0x0&gt;; spi-tx-bus-width = &lt;1&gt;; spi-rx-bus-width = &lt;4&gt;; spi-max-frequency = &lt;50000000&gt;; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; &#125;;&#125;;...在flash子节点下可以自己添加分区, 格式为kernel/arch/arm/boot/dts/zynq-zed.dts12345678910111213141516partition@qspi-fsbl-uboot &#123; label = &quot;qspi-fsbl-uboot&quot;; reg = &lt;0x0 0x500000&gt;;&#125;;partition@qspi-linux &#123; label = &quot;qspi-linux&quot;; reg = &lt;0x500000 0x500000&gt;;&#125;;partition@qspi-device-tree &#123; label = &quot;qspi-device-tree&quot;; reg = &lt;0xA00000 0x20000&gt;;&#125;;partition@qspi-rootfs &#123; label = &quot;qspi-rootfs&quot;; reg = &lt;0xA20000 0x800000&gt;;&#125;;执行以下脚本生成qspi_image.bin:1# mk_bootloader.sh &amp;&amp; mk_kernel.sh &amp;&amp; mk_qspi_image.sh拷贝生成文件到SD卡, 上电启动, 进入系统, 查看设备节点和MTD分区信息:12345# ls /dev/mtd*/dev/mtd0 /dev/mtd0ro /dev/mtdblock0# cat /proc/mtd dev: size erasesize namemtd0: 02000000 00010000 &quot;spi0.0&quot;使用dd命令烧录QSPI Flash:123# dd if=&lt;sdcard_root_dir&gt;/qspi_image.bin of=/dev/mtdblock0 bs=102417687+1 records in17687+1 records out重新启动开发板, 进入系统, OK.测试环境@系统: Windows 7 Professional with SP1@Vivado: 2015.04@虚拟机: OSRC_Miz7_ubuntu_14@开发板: 米联MIZ702N参考文章[移植篇] CH04 LINUX从QSPI启动","categories":[{"name":"xilinx","slug":"xilinx","permalink":"http://yoursite.com/categories/xilinx/"}],"tags":[{"name":"xilinx","slug":"xilinx","permalink":"http://yoursite.com/tags/xilinx/"},{"name":"qspi","slug":"qspi","permalink":"http://yoursite.com/tags/qspi/"}]},{"title":"ZYNQ QSPI驱动分析","slug":"zynq-qspi-01","date":"2018-08-03T03:52:41.000Z","updated":"2018-08-07T09:18:11.788Z","comments":true,"path":"1064320173/","link":"","permalink":"http://yoursite.com/1064320173/","excerpt":"","text":"ZYNQ QSPI框架接口12345678910111213----------------|------------------------------------------------------------MTD Sub System |----------------|------------------------------------------------------------ | spi_nor_read spi_nor_write spi_nor_lock spi_nor_unlockSPI Nor |------------------------------------------------------------ | m25p80_write m25p80_read m25p80_write_reg m25p80_read_reg----------------|------------------------------------------------------------SPI Bus | spi_write spi_sync spi_write_then_read----------------|------------------------------------------------------------SPI Master | zynq_qspi_setup zynq_qspi_start_transfer----------------|------------------------------------------------------------Hardware |----------------|------------------------------------------------------------ZYNQ QSPI驱动注册过程SPI MASTER 驱动注册在驱动入口函数zynq_qspi_probe中, 完成对QSPI Controller的一系列初始化driver/spi/spi-zynq-qspi.c123456789101112static int zynq_qspi_probe(struct platform_device *pdev)&#123; ... /* QSPI controller initializations */ zynq_qspi_init_hw(xqspi); ... master-&gt;setup = zynq_qspi_setup; master-&gt;set_cs = zynq_qspi_chipselect; master-&gt;transfer_one = zynq_qspi_start_transfer; master-&gt;prepare_transfer_hardware = zynq_prepare_transfer_hardware; ...&#125;最后调用spi_register_master()创建设备节点/dev/spiX.Xdriver/spi/spi-zynq-qspi.c12345678910static int zynq_qspi_probe(struct platform_device *pdev)&#123; ... ret = spi_register_master(master); if (ret) &#123; dev_err(&amp;pdev-&gt;dev, \"spi_register_master failed\\n\"); goto clk_dis_all; &#125; ...&#125;SPI BUS 驱动注册在spi_register_master函数的最后, 调用了of_register_spi_device来遍历子节点driver/spi/spi.c1234567int spi_register_master(struct spi_master *master)&#123; ... /* Register devices from the device tree and ACPI */ of_register_spi_devices(master); ...&#125;在该函数中读取设备树上的配置信息, 初始化SPI BUSdriver/spi/spi.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static void of_register_spi_devices(struct spi_master *master)&#123; ... /* Alloc an spi_device */ spi = spi_alloc_device(master); ... /* Select device driver */ rc = of_modalias_node(nc, spi-&gt;modalias, sizeof(spi-&gt;modalias)); ... /* Device address */ rc = of_property_read_u32(nc, \"reg\", &amp;value); spi-&gt;chip_select = value; ... /* Mode (clock phase/polarity/etc.) */ if (of_find_property(nc, \"spi-cpha\", NULL)) spi-&gt;mode |= SPI_CPHA; if (of_find_property(nc, \"spi-cpol\", NULL)) spi-&gt;mode |= SPI_CPOL; if (of_find_property(nc, \"spi-cs-high\", NULL)) spi-&gt;mode |= SPI_CS_HIGH; if (of_find_property(nc, \"spi-3wire\", NULL)) spi-&gt;mode |= SPI_3WIRE; if (of_find_property(nc, \"spi-lsb-first\", NULL)) spi-&gt;mode |= SPI_LSB_FIRST; /* Device DUAL/QUAD mode */ if (!of_property_read_u32(nc, \"spi-tx-bus-width\", &amp;value)) &#123; switch (value) &#123; case 1: break; case 2: spi-&gt;mode |= SPI_TX_DUAL; break; case 4: spi-&gt;mode |= SPI_TX_QUAD; break; default: dev_warn(&amp;master-&gt;dev, \"spi-tx-bus-width %d not supported\\n\", value); break; &#125; &#125; if (!of_property_read_u32(nc, \"spi-rx-bus-width\", &amp;value)) &#123; switch (value) &#123; case 1: break; case 2: spi-&gt;mode |= SPI_RX_DUAL; break; case 4: spi-&gt;mode |= SPI_RX_QUAD; break; default: dev_warn(&amp;master-&gt;dev, \"spi-rx-bus-width %d not supported\\n\", value); break; &#125; &#125; /* Device speed */ rc = of_property_read_u32(nc, \"spi-max-frequency\", &amp;value); spi-&gt;max_speed_hz = value; ...&#125;SPI NOR 驱动注册在of_register_spi_device函数的最后, 调用spi_add_device来加载m25p80设备驱动driver/spi/spi.c1234567static void of_register_spi_devices(struct spi_master *master)&#123; ... /* Register the new device */ rc = spi_add_device(spi); ...&#125;在m25p_probe函数中, 配置spi nor的read/write(读写nor flash), read_reg(配置qspi寄存器), write_reg(配置nor flash寄存器)drivers/mtd/devices/m25p80.c123456789static int m25p_probe(struct spi_device *spi)&#123; ... nor-&gt;read = m25p80_read; nor-&gt;write = m25p80_write; nor-&gt;write_reg = m25p80_write_reg; nor-&gt;read_reg = m25p80_read_reg; ...&#125;调用spi_nor_scan函数, 获取id, 得到nor flash信息, 然后配置type, writesize, size等参数, 设置_erase, _read, _write回调函数drivers/mtd/devices/m25p80.c1234567891011121314int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)&#123; ... jinfo = spi_nor_read_id(nor); ... mtd-&gt;priv = nor; mtd-&gt;type = MTD_NORFLASH; mtd-&gt;writesize = 1; mtd-&gt;flags = MTD_CAP_NORFLASH; mtd-&gt;size = info-&gt;sector_size * info-&gt;n_sectors; mtd-&gt;_erase = spi_nor_erase; mtd-&gt;_read = spi_nor_read_ext; ...&#125;调用mtd_device_register函数, 解析设备树中的分区表, 添加分区信息drivers/mtd/mtdcore.c1234567891011int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types, struct mtd_part_parser_data *parser_data, const struct mtd_partition *parts, int nr_parts)&#123; ... ret = parse_mtd_partitions(mtd, types, &amp;parsed, parser_data); ... ret = mtd_add_device_partitions(mtd, &amp;parsed); ...&#125;参考文章Linux SPI/QSPI nor flash相关驱动代码","categories":[{"name":"xilinx","slug":"xilinx","permalink":"http://yoursite.com/categories/xilinx/"}],"tags":[{"name":"xilinx","slug":"xilinx","permalink":"http://yoursite.com/tags/xilinx/"},{"name":"qspi","slug":"qspi","permalink":"http://yoursite.com/tags/qspi/"}]}]}